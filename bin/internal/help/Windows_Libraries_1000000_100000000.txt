{{QBDLDATE:07-02-2024}}
{{QBDLTIME:23:28:44}}
__NOTOC__
QB64 can support the '''specific Windows Operating System Libraries''' on your PC. They should be located in the '''System32''' folder. Use [[DECLARE LIBRARY]] with the appropriate [[ALIAS]]. Loaded DLL files are NOT required to be named in the Declaration!

<center> '''Note: C++ Header files should be placed in the QB64 folder and are not required after a program is compiled.'''</center>

<center>'''Note: QB64 requires all DLL files to either be with the program or in the C:\WINDOWS\SYSTEM32 folder!'''</center>

<center>Maximum Windows path: MAX_PATH = drive letter + ":\" + 256 + CHR$(0) = 260 characters.</center>

<center>'''{{Text|Your code contribution using the Windows Libraries could end up here!|magenta}}'''</center>

{|class="wikitable" width="100%"
!colspan="4"|Table of Contents
|-
|1 [[#Computer_Date/Time|Computer Date/Time]]||10 [[#Focus|Focus]]||19 [[#Open_another_Program|Open another Program]]||28 [[#Window_Focus|Window Focus]]
|-
|2 [[#Borderless_Window|Borderless Window]]||11 [[#Folder_Dialog_Box|Folder Dialog Box]]||20 [[#Play_WAV_Sounds|Play WAV Sounds]]||29 [[#Windows_Menu|Windows Menu]]
|-
|3 [[#Color_Dialog_Box|Color Dialog Box]]||12 [[#Font_Dialog_Box|Font Dialog Box]]||21 [[#Run_One_Instance|Run One Instance]]||30 [[#Windows_Notification|Windows Notification]]
|-
|4 [[#Desktop_Size|Desktop Size]]||13 [[#Registered_Fonts|Registered Fonts]]||22 [[#Send_Keys|Send Keys]]||31 [[#Windows_Ports|Windows Ports]]
|-
|5 [[#Directory_Environment|Directory Environment]]||14 [[#Game_Pad|Game Pad]]||23 [[#System_Metrics|System Metrics]]||32 [[#Windows_Sounds|Windows Sounds]]
|-
|6 [[#Disk_Drives|Disk Drives]]||15 [[#Hot_Keys_(maximize)|Hot Keys (maximize)]]||24 [[#Top_Most_Window|Top Most Window]]||33 [[#Window_Transparency|Window Transparency]]
|-
|7 [[#File_Attributes|File Attributes]]||16 [[#Keyboard_Lock_Settings|Keyboard Lock Settings]]||25 [[#Video_File_Player|Video File Player]]||34 [[#Windows_User|Windows User]]
|-
|8 [[#File_Open_and_Save_Dialog|File Open and Save Dialog]]||17 [[#Message_Box|Message Box]]||26 [[#Web_Page_Download|Web Page Download]]||35 [[#Windows_Version|Windows Version]]
|-
|9 [[#File_Times|File Times]]||18 [[#Mouse_Area|Mouse Area]]||27 [[#Windows_API|Windows API]]||36 [[#Reference|Reference]]
|}

{{FixedStart}}
'''                         Windows API Data Structures'''

'''Name            Description             Bits             QB64 Type'''
bit            8 bits in one byte         1                [[_BIT]]
nybble         2 nybbles in one byte      4                [[_BIT]] * 4
byte           1 byte (2 nybbles)         8                [[_BYTE]]
Boolean        1 byte (signed/unsigned)   8                [[_BYTE]]
CharA(FunctA)  [[ASCII]] character            8([[LEN]](buffer))   [[_BYTE]]
WORD           2 bytes                   16                [[INTEGER]]
CharW(FunctW)  [[Unicode]] wide character    16([[LEN]](buffer)\2) [[INTEGER]]
DWORD          4 bytes                   32                [[LONG]]
QWORD          8 bytes                   64                [[_INTEGER64]]
LP or hwnd     Short or Long Pointer     ANY [[INTEGER]]       [[_OFFSET]]

                  Void * in C code is also an [[_OFFSET]]
{{FixedEnd}}
<center>'''[http://msdn.microsoft.com/en-us/library/aa383751(v=vs.85).aspx Windows Data Types]'''</center>

<center>'''[http://doc.pcsoft.fr/en-US/?6510001 Windows 32 API constant values]'''</center>


== Computer Date/Time ==
'''NOTE: You might need to run this program as Administrator'''
{{CodeStart}}
'=============
'DATE&TIME.BAS
'=============
'A {{Cl|DATE$}} and {{Cl|TIME$}} alternative.
'Gets & Sets System DATE & TIME using Windows API.
'Coded for QB64 by Dav FEB/2012

'======================================================================
'NOTE: THIS DEMO WILL ATTEMPT TO CHANGE YOUR SYSTEM DATE FOR 5 SECONDS.
'     AFTER 5 SECONDS IT WILL ATTEMPT TO RESTORE ORIGINAL DATE SETTING.
'======================================================================

{{Cl|TYPE}} SYSTEMTIME
    wYear {{Cl|AS}} {{Cl|INTEGER}}
    wMonth {{Cl|AS}} {{Cl|INTEGER}}
    wDayOfWeek {{Cl|AS}} {{Cl|INTEGER}}
    wDay {{Cl|AS}} {{Cl|INTEGER}}
    wHour {{Cl|AS}} {{Cl|INTEGER}}
    wMinute {{Cl|AS}} {{Cl|INTEGER}}
    wSecond {{Cl|AS}} {{Cl|INTEGER}}
    wMilliseconds {{Cl|AS}} {{Cl|INTEGER}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "Kernel32"
'== NOTE: SetSystemTime& returns Zero if it Fails.
'== NOTE: GetSystemTime does not return a value.
    {{Cl|FUNCTION}} SetSystemTime& (lpSystemTime {{Cl|AS}} SYSTEMTIME)
    {{Cl|SUB}} GetSystemTime (lpSystemTime {{Cl|AS}} SYSTEMTIME)
{{Cl|DECLARE LIBRARY|END DECLARE}}

' Holds current values...
{{Cl|DIM}} CurrentTime {{Cl|AS}} SYSTEMTIME

' For the new values to set...
{{Cl|DIM}} NewTime {{Cl|AS}} SYSTEMTIME

' Get & Show current System Date/Time
GetSystemTime CurrentTime

{{Cl|PRINT}}
{{Cl|PRINT}} "--------------------------------"
{{Cl|PRINT}} "Current System DATE & TIME is..."
{{Cl|PRINT}} "DATE:"; CurrentTime.wMonth; "-"; CurrentTime.wDay; "-"; CurrentTime.wYear
{{Cl|PRINT}} "TIME:"; CurrentTime.wHour; ":"; CurrentTime.wMinute; ":"; CurrentTime.wSecond
{{Cl|PRINT}} "--------------------------------"


'=== Now Set new DATE only
'=== {{Cl|NOT}}ICE we're using CurrentTime TIME value's '<==
'=== So we're just changing the DATE, not the TIME here...

NewTime.wYear = 2011     'move date back to prevent trial version expiration!
NewTime.wMonth = 12
NewTime.wDayOfWeek = -1
NewTime.wDay = 25
NewTime.wHour = CurrentTime.wHour '<==
NewTime.wMinute = CurrentTime.wMinute '<==
NewTime.wSecond = CurrentTime.wSecond '<==
NewTime.wMilliseconds = CurrentTime.wMilliseconds '<==

' Set the new values
x = SetSystemTime&(NewTime)
{{Cl|IF...THEN|IF}} x = 0 {{Cl|THEN}} {{Cl|PRINT}} "Failed to change DATE/TIME!": {{Cl|END}}

' Grab new System DATE settings...
' Temporary holding space...for TIME...
{{Cl|DIM}} CurrentTime2 {{Cl|AS}} SYSTEMTIME

GetSystemTime CurrentTime2

{{Cl|PRINT}}
{{Cl|PRINT}} "--------------------------------"
{{Cl|PRINT}} "Now the NEW System DATE is..."
{{Cl|PRINT}} "DATE:"; CurrentTime2.wMonth; "-"; CurrentTime2.wDay; "-"; CurrentTime2.wYear
{{Cl|PRINT}} "--------------------------------"
{{Cl|PRINT}}
{{Cl|PRINT}} "Waiting 5 seconds! Check computer date in taskbar....."


{{Cl|SLEEP}} 5

'=== Now set everything back to what it was at the beginning.
'=== Using TIME values from CurrentTime2 so we don't lose any
'=== seconds from SLEEPing....

' Grab current values again, keeps the running TIME...
GetSystemTime CurrentTime2

{{Cl|PRINT}} "Resetting DATE back..."

NewTime.wYear = CurrentTime.wYear
NewTime.wMonth = CurrentTime.wMonth
NewTime.wDayOfWeek = -1
NewTime.wDay = CurrentTime.wDay
NewTime.wHour = CurrentTime2.wHour '<==
NewTime.wMinute = CurrentTime2.wMinute '<==
NewTime.wSecond = CurrentTime2.wSecond '<==
NewTime.wMilliseconds = CurrentTime2.wMilliseconds '<==

' Set the DATE & TIME values back

x = SetSystemTime&(NewTime):
{{Cl|IF...THEN|IF}} x = 0 {{Cl|THEN}} {{Cl|PRINT}} "Failed to change DATE/TIME!": {{Cl|END}}

' Now let's get & show Current values, see if it worked...

GetSystemTime CurrentTime

{{Cl|PRINT}}
{{Cl|PRINT}} "--------------------------------"
{{Cl|PRINT}} "Now the System DATE & TIME is..."
{{Cl|PRINT}} "DATE:"; CurrentTime.wMonth; "-"; CurrentTime.wDay; "-"; CurrentTime.wYear
{{Cl|PRINT}} "TIME:"; CurrentTime.wHour; ":"; CurrentTime.wMinute; ":"; CurrentTime.wSecond
{{Cl|PRINT}} "--------------------------------"

{{Cl|END}}
{{CodeEnd}}
{{Small|Code by Dav}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Borderless Window ==

{{CodeStart}}
'============
'NOBORDER.BAS
'============

{{Cl|DECLARE LIBRARY|DECLARE CUSTOMTYPE LIBRARY}}
    {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "User32"
    {{Cl|FUNCTION}} GetWindowLongA& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nIndex {{Cl|AS}} {{Cl|LONG}})
    {{Cl|FUNCTION}} SetWindowLongA& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nIndex {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} dwNewLong {{Cl|AS}} {{Cl|LONG}})
    {{Cl|FUNCTION}} SetWindowPos& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} hWndInsertAfter {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} x {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} y {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} cx {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} cy {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} wFlags {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

GWL_STYLE = -16
WS_BORDER = {{Cl|&H}}800000

{{Cl|_TITLE}} "No Border"
hwnd& = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "No Border" + {{Cl|CHR$}}(0))

{{Cl|PRINT}} "Press any key for no border...": A$ = {{Cl|INPUT$}}(1)

winstyle& = GetWindowLongA&(hwnd&, GWL_STYLE)
a& = SetWindowLongA&(hwnd&, GWL_STYLE, winstyle& {{Cl|AND (boolean)|AND}} {{Cl|NOT}} WS_BORDER)
a& = SetWindowPos&(hwnd&, 0, 0, 0, 0, 0, 39)

{{Cl|PRINT}} "Press any key to get back border...": {{Cl|SLEEP}}

winstyle& = GetWindowLongA&(hwnd&, GWL_STYLE)
a& = SetWindowLongA&(hwnd&, GWL_STYLE, winstyle& {{Cl|OR (boolean)|OR}} WS_BORDER)
a& = SetWindowPos&(hwnd&, 0, 0, 0, 0, 0, 39)

{{Cl|PRINT}} "The end"
{{CodeEnd}}
{{Small|Code by Dav}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Color Dialog Box ==
<center>The Color Dialog Box can set custom colors and alpha saturation levels.</center>
{{CodeStart}}
' Color Dialog flag constants (use + or {{Cl|OR (boolean)|OR}} to use more than 1 flag)
{{Cl|CONST}} CC_RGBINIT = {{Cl|&H}}1& '           Sets the initial color (don't know how to set it)
{{Cl|CONST}} CC_FULLOPEN = {{Cl|&H}}2& '          Opens all dialog sections such as the custom color selector
{{Cl|CONST}} CC_PREVENTFULLOPEN = {{Cl|&H}}4& '   Prevents the user from opening the custom color selector
{{Cl|CONST}} CC_SHOWHELP = {{Cl|&H}}8& '          Shows the help button (USELESS!)
'----------------------------------------------------------------------------------------
{{Cl|$IF}} 32BIT {{Cl|THEN}} '                Checking for 32 bit IDE
{{Cl|TYPE}} COLORDIALOGTYPE
  lStructSize {{Cl|AS}} {{Cl|LONG}} '         Length of this {{Cl|TYPE}} structure
  hwndOwner {{Cl|AS}} {{Cl|LONG}} '           Dialog owner's handle
  hInstance {{Cl|AS}} {{Cl|LONG}} '           ?
  rgbResult {{Cl|AS}} {{Cl|LONG}} '           The RGB color the user selected
  lpCustColors {{Cl|AS}} {{Cl|_OFFSET}} '     Pointer to an array of 16 custom colors (will be changed by user)
  flags {{Cl|AS}} {{Cl|LONG}} '               Dialog flags
  lCustData {{Cl|AS}} {{Cl|LONG}} '           Custom data
  lpfnHook {{Cl|AS}} {{Cl|LONG}} '            Hook
  lpTemplateName {{Cl|AS}} {{Cl|_OFFSET}} '   Custom template
{{Cl|END}} {{Cl|TYPE}}
{{Cl|$ELSE}} '                         If the IDE is 64 bit then...
{{Cl|TYPE}} COLORDIALOGTYPE
  lStructSize {{Cl|AS}} {{Cl|_INTEGER64}} '   Length of this {{Cl|TYPE}} structure
  hwndOwner {{Cl|AS}} {{Cl|_INTEGER64}} '     Dialog owner's handle
  hInstance {{Cl|AS}} {{Cl|_INTEGER64}} '     ?
  rgbResult {{Cl|AS}} {{Cl|_INTEGER64}} '     The RGB color the user selected
  lpCustColors {{Cl|AS}} {{Cl|_OFFSET}} '     Pointer to an array of 16 custom colors (will be changed by user)
  flags {{Cl|AS}} {{Cl|_INTEGER64}} '         Dialog flags
  lCustData {{Cl|AS}} {{Cl|_INTEGER64}} '     Custom data
  lpfnHook {{Cl|AS}} {{Cl|_INTEGER64}} '      Hook
  lpTemplateName {{Cl|AS}} {{Cl|_OFFSET}} '   Custom template
{{Cl|END}} {{Cl|TYPE}}
{{Cl|$END IF}}

{{Cl|DIM}} ColorString {{Cl|AS}} {{Cl|STRING}} * 64
ColorString = "FFFFFFFFFF" 'not sure how this works?

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "comdlg32"
  {{Cl|FUNCTION}} ChooseColorA& (DIALOGPARAMS {{Cl|AS}} COLORDIALOGTYPE) '    Yet the also famous color dialog box
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY}}
  {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) ' To get hWnd handle, or use {{Cl|_WINDOWHANDLE}}
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|SCREEN}} {{Cl|_NEWIMAGE}}(640, 480, 12) '32 or 16 or 256 color screen modes
{{Cl|_TITLE}} "Color Common Dialog demo" 'set Title of program
hWnd& = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "Color Common Dialog demo" + {{Cl|CHR$}}(0)) 'get window handle using {{Cl|_TITLE}} string

clr~& = ChooseColor&({{Cl|_RGB32}}(0, 0, 0), ColorString$, Cancel, CC_FULLOPEN, hWnd&)

{{Cl|CLS}} , clr~& 'make background chosen color
{{Cl|LOCATE}} 10, 31
{{Cl|IF...THEN|IF}} Cancel <> -1 {{Cl|THEN}}
  {{Cl|COLOR}} {{Cl|_RGB}}(255, 255, 255) 'white text
  {{Cl|PRINT}} "Color:"; clr~&; "{{Cl|&H}}" + {{Cl|HEX$}}(clr~&) '  use last color chosen
  {{Cl|PRINT}} ColorString$ '              display user custom color values chosen
{{Cl|ELSE}}: {{Cl|PRINT}} "No color was chosen!"
{{Cl|END IF}}
{{Cl|END}}

{{Cl|FUNCTION}} ChooseColor& (InitialColor&, CustomColors$, Cancel, Flags&, hWnd&)
' Parameters:
'  InitialColor&  - The initial color used, will take effect if CC_RGBINIT flag is specified
'  CustomColors$  - A 64-byte string where the user's custom colors will be stored (4 bytes per color in RGB0 format).
'  Cancel         - Variable where the cancel flag will be stored.
'  Flags&         - Dialog flags
'  hWnd&          - Your program's window handle that should be aquired by the FindWindow function.

{{Cl|DIM}} ColorCall {{Cl|AS}} COLORDIALOGTYPE

ColorCall.rgbResult = {{Cl|_RGB32}}({{Cl|_BLUE32}}(InitialColor&), {{Cl|_GREEN32}}(InitialColor&), {{Cl|_RED32}}(InitialColor&))
ColorCall.lStructSize = {{Cl|LEN}}(ColorCall)
ColorCall.hwndOwner = hWnd&
ColorCall.flags = Flags&
ColorCall.lpCustColors = {{Cl|_OFFSET (function)|_OFFSET}}(CustomColors$)

' Do dialog call
Result = ChooseColorA(ColorCall)
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}}
  rgbResult& = ColorCall.rgbResult
  ' Swap RED and BLUE color intensity values using {{Cl|_RGB}}
  ChooseColor& = {{Cl|_RGB}}({{Cl|_BLUE32}}(rgbResult&), {{Cl|_GREEN32}}(rgbResult&), {{Cl|_RED32}}(rgbResult&))
{{Cl|ELSE}}
  Cancel = -1
{{Cl|END IF}}
{{Cl|END FUNCTION}}
{{CodeEnd}}
{{Small|Adapted from code by Jobert14}}
: ''Note:'' The ChooseColor value is converted using [[_RGB32]] with the Blue and Red values being swapped.


<center>'''Converting 32 bit Dialog Box Color values for 4 or 8 BPP Screen modes'''</center>
{{TextStart}}
{{Cb|SCREEN}} {{Cb|_NEWIMAGE}}(640, 480, 12) 'change from screen 12 to 32 to see the difference
rgbresult& = {{Cb|&H}}8080FF 'Dialog box long color reverse {{Cb|HEX$}} return value
clr~& = {{Cb|_RGB}}({{Cb|_BLUE32}}(rgbresult&), {{Cb|_GREEN32}}(rgbresult&), {{Cb|_RED32}}(rgbresult&)) 'swap red and blue
{{Cb|COLOR}} clr~&: {{Cb|PRINT}} clr~&, {{Cb|HEX$}}(clr~&) '_UNSIGNED LONG color values
{{CodeEnd}}
: ''Note:'' The [[_RGB]] value returned is full [[_ALPHA]]. Use _ALPHA or [[_RGBA]] to set the transparency in a program.

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Desktop Size ==

: Returns the Left, Top, Right and Bottom coordinates of the current desktop area.
{{CodeStart}}
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
    {{Cl|FUNCTION}} SystemParametersInfoW& ({{Cl|BYVAL}} uiAction~&, {{Cl|BYVAL}} uiParam~&, {{Cl|BYVAL}} pvParam%&, {{Cl|BYVAL}} fWinlni~&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|CONST}} SPI_GETWORKAREA = {{Cl|&H}}30

{{Cl|TYPE}} RECT
    left {{Cl|AS}} {{Cl|LONG}}
    top {{Cl|AS}} {{Cl|LONG}}
    right {{Cl|AS}} {{Cl|LONG}}
    bottom {{Cl|AS}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}
{{Cl|DIM}} Rec {{Cl|AS}} RECT

{{Cl|IF...THEN|IF}} 0 = SystemParametersInfoW(SPI_GETWORKAREA, 0, {{Cl|_OFFSET (function)|_OFFSET}}(Rec), 0) {{Cl|THEN}}
    'function failed. You may call kernel32's GetLastError for more info.
    {{Cl|PRINT}} "failed."
{{Cl|END IF}}

{{Cl|PRINT}} Rec.left
{{Cl|PRINT}} Rec.top
{{Cl|PRINT}} Rec.right
{{Cl|PRINT}} Rec.bottom
{{Cl|PRINT}}
scr& = {{Cl|_SCREENIMAGE}}
{{Cl|PRINT}} {{Cl|_WIDTH (function)|_WIDTH}}(scr&)
{{Cl|PRINT}} {{Cl|_HEIGHT}}(scr&)
{{Cl|_FREEIMAGE}} scr&

{{Cl|END}}
{{CodeEnd}}

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Directory Environment ==
: Returns various system environment settings including the current program's EXE name.
{{CodeStart}}
{{Cl|DECLARE LIBRARY}}   'Directory Information using KERNEL32 provided by Dav
{{Cl|FUNCTION}} WINDirectory {{Cl|ALIAS}} GetWindowsDirectoryA (lpBuffer {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} nSize {{Cl|AS}} {{Cl|LONG}})
{{Cl|FUNCTION}} SYSDirectory {{Cl|ALIAS}} GetSystemDirectoryA (lpBuffer {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} nSize {{Cl|AS}} {{Cl|LONG}})
{{Cl|FUNCTION}} CURDirectory {{Cl|ALIAS}} GetCurrentDirectoryA ({{Cl|BYVAL}} nBufferLen {{Cl|AS}} {{Cl|LONG}}, lpBuffer {{Cl|AS}} {{Cl|STRING}})
{{Cl|FUNCTION}} TempPath {{Cl|ALIAS}} GetTempPathA ({{Cl|BYVAL}} nBufferLen {{Cl|AS}} {{Cl|LONG}}, lpBuffer {{Cl|AS}} {{Cl|STRING}})
{{Cl|FUNCTION}} GetModuleFileNameA ({{Cl|BYVAL}} hModule {{Cl|AS}} {{Cl|LONG}}, lpFileName {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} nSize {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

'=== SHOW WINDOWS DIRECTORY
WinDir$ = {{Cl|SPACE$}}(144)
Result = WINDirectory(WinDir$, {{Cl|LEN}}(WinDir$))
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "{{Cl|WINDOW}}S DIRECTORY: "; {{Cl|LEFT$}}(WinDir$, Result)

'=== SHOW SYSTEM DIRECTORY
SysDir$ = {{Cl|SPACE$}}(144)
Result = SYSDirectory(SysDir$, {{Cl|LEN}}(SysDir$))
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "{{Cl|SYSTEM}} DIRECTORY: "; {{Cl|LEFT$}}(SysDir$, Result)

'=== SHOW CURRENT DIRECTORY
CurDir$ = {{Cl|SPACE$}}(255)
Result = CURDirectory({{Cl|LEN}}(CurDir$), CurDir$)
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "CURRENT DIRECTORY: "; {{Cl|LEFT$}}(CurDir$, Result)

'=== SHOW TEMP DIRECTORY
TempDir$ = {{Cl|SPACE$}}(100)
Result = TempPath({{Cl|LEN}}(TempDir$), TempDir$)
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "TEMP DIRECTORY: "; {{Cl|LEFT$}}(TempDir$, Result)

'=== SHOW CURRENT PROGRAM
FileName$ = {{Cl|SPACE$}}(256)
Result = GetModuleFileNameA(0, FileName$, {{Cl|LEN}}(FileName$))
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "CURRENT PROGRAM: "; {{Cl|LEFT$}}(FileName$, Result)
{{Cl|END}}
{{CodeEnd}}
{{Small|Windows APIs courtesy of Dav}}


: Returns the DOS 8.3 path and file name. The DLL used is in the QB64 folder.
{{CodeStart}}
{{Cl|DECLARE LIBRARY}}   'Directory Information using KERNEL32
{{Cl|FUNCTION}} GetShortPathNameA (lpLongPath {{Cl|AS}} {{Cl|STRING}}, lpShortPath {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} cBufferLen {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

'=== SHOW SHORT PATH NAME
FileOrPath$ = "c:\qb64\SDL_image.dll"  '<< change to a relevant path or file name on computer
ShortPathName$ = {{Cl|SPACE$}}(260)
Result = GetShortPathNameA(FileOrPath$ + {{Cl|CHR$}}(0), ShortPathName$, {{Cl|LEN}}(ShortPathName$))
{{Cl|IF...THEN|IF}} Result {{Cl|THEN}} {{Cl|PRINT}} "SHORT PATH NAME: " + ShortPathName$ {{Cl|ELSE}} {{Cl|PRINT}} "NOT Found!"
{{Cl|END}}
{{CodeEnd}}
{{Small|Courtesy of Dav}}


== Disk Drives ==

Uses Kernel32 API to lists all available drives on system. Shows the drives type: HD/CD/DVD/RAM/NET/Removable/Unknown

{{CodeStart}}
{{Cl|CONST}} REMOVABLE = 2
{{Cl|CONST}} FIXED = 3
{{Cl|CONST}} REMOTE = 4
{{Cl|CONST}} CDROM = 5
{{Cl|CONST}} RAMDISK = 6

{{Cl|DECLARE LIBRARY}}
  {{Cl|FUNCTION}} GetDriveTypeA& (nDrive {{Cl|AS}} {{Cl|STRING}})
  {{Cl|FUNCTION}} GetLogicalDriveStringsA ({{Cl|BYVAL}} nBuff {{Cl|AS}} {{Cl|LONG}}, lpbuff {{Cl|AS}} {{Cl|STRING}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} DList {{Cl|AS}} {{Cl|STRING}}, DL {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} i {{Cl|AS}} {{Cl|LONG}}, typ {{Cl|AS}} {{Cl|LONG}}

i = GetLogicalDriveStringsA(0, DList) 'zero returns the drive string byte size
DList = {{Cl|SPACE$}}(i) 'set drive string length. Each drive is followed by CHR$(0)
i = GetLogicalDriveStringsA(i, DList) 'the byte size returns a string that long
{{Cl|PRINT}} DList

{{Cl|FOR...NEXT|FOR}} n = 65 {{Cl|TO}} 90
  {{Cl|IF...THEN|IF}} {{Cl|INSTR}}(DList, {{Cl|CHR$}}(n)) {{Cl|THEN}}
    DL = {{Cl|CHR$}}(n) + ":\" + {{Cl|CHR$}}(0)
    typ = GetDriveTypeA(DL)
    {{Cl|SELECT CASE}} typ
      {{Cl|CASE}} REMOVABLE: {{Cl|PRINT}} DL + "Removable"
      {{Cl|CASE}} FIXED: {{Cl|PRINT}} DL + "Fixed"
      {{Cl|CASE}} REMOTE: {{Cl|PRINT}} DL + "Remote"
      {{Cl|CASE}} CDROM: {{Cl|PRINT}} DL + "CDROM"
      {{Cl|CASE}} RAMDISK: {{Cl|PRINT}} DL + "RAM"
    {{Cl|END SELECT}}
  {{Cl|END IF}}
{{Cl|NEXT}}
{{CodeEnd}}
{{Small|Adapted from code by Dav}}
: ''Note:'' The length of the string returned by ''GetLogicalDriveStringsA'' can be divided by 4 to tell the number of physical and ram drives.

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== File Attributes ==

{{CodeStart}}{{Cl|DECLARE LIBRARY}}
    {{Cl|FUNCTION}} GetFileAttributes& (f$)
    {{Cl|FUNCTION}} SetFileAttributes& (f$, {{Cl|BYVAL}} attrib&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|CONST}} INVALID_FILE_ATTRIBUTES = -1
{{Cl|CONST}} FILE_ATTRIBUTE_{{Cl|READ}}ONLY = 1
{{Cl|CONST}} FILE_ATTRIBUTE_HIDDEN = 2
{{Cl|CONST}} FILE_ATTRIBUTE_{{Cl|SYSTEM}} = 4
{{Cl|CONST}} FILE_ATTRIBUTE_DIRECTORY = 16
{{Cl|CONST}} FILE_ATTRIBUTE_ARCHIVE = 32

file$ = "temp.txt"

a = GetFileAttributes(file$)
{{Cl|PRINT}} a 'if no file, then you'll see a -1 here

{{Cl|OPEN}} file$ {{Cl|FOR...NEXT|FOR}} {{Cl|OUTPUT}} {{Cl|AS}} #1
{{Cl|CLOSE}} #1

a = GetFileAttributes(file$)
{{Cl|PRINT}} a 'a new file, it prints 32 for me here

x = SetFileAttributes(file$, 1) 'set the read only flag
a = GetFileAttributes(file$)
{{Cl|PRINT}} a 'notice, it prints 1 here and not 32.  We didn't add a flag, we changed it completel
{{CodeEnd}}


== File Open and Save Dialog ==

<center>'''Open and Save Dialog Boxes get file names'''</center>
{{CodeStart}}
' Dialog flag constants (use + or {{Cl|OR}} to use more than 1 flag value)
{{Cl|CONST}} OFN_ALLOWMULTISELECT = {{Cl|&H}}200& '  Allows the user to select more than one file, not recommended!
{{Cl|CONST}} OFN_CREATEPROMPT = {{Cl|&H}}2000& '     Prompts if a file not found should be created(GetOpenFileName only).
{{Cl|CONST}} OFN_EXTENSIONDIFFERENT = {{Cl|&H}}400& 'Allows user to specify file extension other than default extension.
{{Cl|CONST}} OFN_FILEMUSTEXIST = {{Cl|&H}}1000& '    Chechs File name exists(GetOpenFileName only).
{{Cl|CONST}} OFN_HIDEREADONLY = {{Cl|&H}}4& '        Hides read-only checkbox(GetOpenFileName only)
{{Cl|CONST}} OFN_NOCHANGEDIR = {{Cl|&H}}8& '         Restores the current directory to original value if user changed
{{Cl|CONST}} OFN_NODEREFERENCELINKS = {{Cl|&H}}100000& 'Returns path and file name of selected shortcut(.LNK) file instead of file referenced.
{{Cl|CONST}} OFN_NONETWORKBUTTON = {{Cl|&H}}20000& ' Hides and disables the Network button.
{{Cl|CONST}} OFN_NOREADONLYRETURN = {{Cl|&H}}8000& ' Prevents selection of read-only files, or files in read-only subdirectory.
{{Cl|CONST}} OFN_NOVALIDATE = {{Cl|&H}}100& '        Allows invalid file name characters.
{{Cl|CONST}} OFN_OVERWRITEPROMPT = {{Cl|&H}}2& '     Prompts if file already exists(GetSaveFileName only)
{{Cl|CONST}} OFN_PATHMUSTEXIST = {{Cl|&H}}800& '     Checks Path name exists (set with OFN_FILEMUSTEXIST).
{{Cl|CONST}} OFN_READONLY = {{Cl|&H}}1& '            Checks read-only checkbox. Returns if checkbox is checked
{{Cl|CONST}} OFN_SHAREAWARE = {{Cl|&H}}4000& '       Ignores sharing violations in networking
{{Cl|CONST}} OFN_SHOWHELP = {{Cl|&H}}10& '           Shows the help button (useless!)
'--------------------------------------------------------------------------------------------

{{Cl|DEFINT}} A-Z 'not recommended to use this statement in a final application!

{{Cl|TYPE}} FILEDIALOGTYPE
{{Cl|$IF}} 32BIT {{Cl|THEN}}
  lStructSize {{Cl|AS}} {{Cl|LONG}} '        For the DLL call
  hwndOwner {{Cl|AS}} {{Cl|LONG}} '          Dialog will hide behind window when not set correctly
  hInstance {{Cl|AS}} {{Cl|LONG}} '          Handle to a module that contains a dialog box template.
  lpstrFilter {{Cl|AS}} {{Cl|_OFFSET}} '     Pointer of the string of file filters
  lpstrCustFilter {{Cl|AS}} {{Cl|_OFFSET}}
  nMaxCustFilter {{Cl|AS}} {{Cl|LONG}}
  nFilterIndex {{Cl|AS}} {{Cl|LONG}} '       One based starting filter index to use when dialog is called
  lpstrFile {{Cl|AS}} {{Cl|_OFFSET}} '       String full of 0's for the selected file name
  nMaxFile {{Cl|AS}} {{Cl|LONG}} '           Maximum length of the string stuffed with 0's minus 1
  lpstrFileTitle {{Cl|AS}} {{Cl|_OFFSET}} '  Same as lpstrFile
  nMaxFileTitle {{Cl|AS}} {{Cl|LONG}} '      Same as nMaxFile
  lpstrInitialDir {{Cl|AS}} {{Cl|_OFFSET}} ' Starting directory
  lpstrTitle {{Cl|AS}} {{Cl|_OFFSET}} '      Dialog title
  flags {{Cl|AS}} {{Cl|LONG}} '              Dialog flags
  nFileOffset {{Cl|AS}} {{Cl|INTEGER}} '     Zero-based offset from path beginning to file name string pointed to by lpstrFile
  nFileExtension {{Cl|AS}} {{Cl|INTEGER}} '  Zero-based offset from path beginning to file extension string pointed to by lpstrFile.
  lpstrDefExt {{Cl|AS}} {{Cl|_OFFSET}} '     Default/selected file extension
  lCustData {{Cl|AS}} {{Cl|LONG}}
  lpfnHook {{Cl|AS}} {{Cl|LONG}}
  lpTemplateName {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|$ELSE}}
  lStructSize {{Cl|AS}} {{Cl|_OFFSET}} '      For the DLL call
  hwndOwner {{Cl|AS}} {{Cl|_OFFSET}} '        Dialog will hide behind window when not set correctly
  hInstance {{Cl|AS}} {{Cl|_OFFSET}} '        Handle to a module that contains a dialog box template.
  lpstrFilter {{Cl|AS}} {{Cl|_OFFSET}} '      Pointer of the string of file filters
  lpstrCustFilter {{Cl|AS}} {{Cl|LONG}}
  nMaxCustFilter {{Cl|AS}} {{Cl|LONG}}
  nFilterIndex {{Cl|AS}} {{Cl|_INTEGER64}} '  One based starting filter index to use when dialog is called
  lpstrFile {{Cl|AS}} {{Cl|_OFFSET}} '        String full of 0's for the selected file name
  nMaxFile {{Cl|AS}} {{Cl|_OFFSET}} '         Maximum length of the string stuffed with 0's minus 1
  lpstrFileTitle {{Cl|AS}} {{Cl|_OFFSET}} '   Same as lpstrFile
  nMaxFileTitle {{Cl|AS}} {{Cl|_OFFSET}} '    Same as nMaxFile
  lpstrInitialDir {{Cl|AS}} {{Cl|_OFFSET}} '  Starting directory
  lpstrTitle {{Cl|AS}} {{Cl|_OFFSET}} '       Dialog title
  flags {{Cl|AS}} {{Cl|_INTEGER64}} '         Dialog flags
  nFileOffset {{Cl|AS}} {{Cl|_INTEGER64}} '   Zero-based offset from path beginning to file name string pointed to by lpstrFile
  nFileExtension {{Cl|AS}} {{Cl|_INTEGER64}} 'Zero-based offset from path beginning to file extension string pointed to by lpstrFile.
  lpstrDefExt {{Cl|AS}} {{Cl|_OFFSET}} '      Default/selected file extension
  lCustData {{Cl|AS}} {{Cl|_INTEGER64}}
  lpfnHook {{Cl|AS}} {{Cl|_INTEGER64}}
  lpTemplateName {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|$END IF}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "comdlg32"    ' Library declarations using _OFFSET types
  {{Cl|FUNCTION}} GetOpenFileNameA& (DIALOGPARAMS {{Cl|AS}} FILEDIALOGTYPE) ' The Open file dialog
  {{Cl|FUNCTION}} GetSaveFileNameA& (DIALOGPARAMS {{Cl|AS}} FILEDIALOGTYPE) ' The Save file dialog
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY}}
  {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) ' To get hWnd handle
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|_TITLE}} "FileOpen Common Dialog demo"                           'set Title of program
hWnd& = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "Open and Save Dialog demo" + {{Cl|CHR$}}(0)) 'get window handle using _TITLE string

' Do the Open File dialog call!
Filter$ = "Batch files (*.bat)|*.BAT|JPEG images (*.jpg)|*.JPG|All files (*.*)|*.*"
Flags& = OFN_FILEMUSTEXIST + OFN_NOCHANGEDIR + OFN_READONLY  '    add flag constants here
OFile$ = GetOpenFileName$("YEAH! Common Dialogs in QB64!!!", ".\", Filter$, 1, Flags&, hWnd&)

{{Cl|IF...THEN|IF}} OFile$ = "" {{Cl|THEN}}   ' Display Open dialog results
  {{Cl|PRINT}} "Shame on you! You didn't pick any file..."
{{Cl|ELSE}}
  {{Cl|PRINT}} "You picked this file: "
  {{Cl|PRINT}} OFile$
  {{Cl|IF...THEN|IF}} (Flags& {{Cl|AND (boolean)|AND}} OFN_READONLY) {{Cl|THEN}} {{Cl|PRINT}} "Read-only checkbox checked." 'read-only value in return
{{Cl|END IF}}

{{Cl|_DELAY}} 5 ' Do the Save File dialog call!
Filter$ = "Basic files (*.bas)|*.BAS|All files (*.*)|*.*"
Flags& = OFN_OVERWRITEPROMPT + OFN_NOCHANGEDIR '   add flag constants here
SFile$ = GetSaveFileName$("Save will not create a file!!!", ".\", Filter$, 1, Flags&, hWnd&)

{{Cl|IF...THEN|IF}} SFile$ = "" {{Cl|THEN}}     ' Display Save dialog results
  {{Cl|PRINT}} "You didn't save the file..."
{{Cl|ELSE}}
  {{Cl|PRINT}} "You saved this file: "
  {{Cl|PRINT}} SFile$
{{Cl|END IF}}
{{Cl|END}}

{{Cl|FUNCTION}} GetOpenFileName$ (Title$, InitialDir$, Filter$, FilterIndex, Flags&, hWnd&)
'  Title$      - The dialog title.
'  InitialDir$ - If this left blank, it will use the directory where the last opened file is
'  located. Specify ".\" if you want to always use the current directory.
'  Filter$     - File filters separated by pipes (|) in the same format as using VB6 common dialogs.
'  FilterIndex - The initial file filter to use. Will be altered by user during the call.
'  Flags&      - Dialog flags. Will be altered by the user during the call.
'  hWnd&       - Your program's window handle that should be aquired by the FindWindow function.
'
' Returns: Blank when cancel is clicked otherwise, the file name selected by the user.
' FilterIndex and Flags& will be changed depending on the user's selections.

{{Cl|DIM}} OpenCall {{Cl|AS}} FILEDIALOGTYPE  ' Needed for dialog call

fFilter$ = Filter$
{{Cl|FOR...NEXT|FOR}} R = 1 {{Cl|TO}} {{Cl|LEN}}(fFilter$) ' Replace the pipes with character zero
  {{Cl|IF...THEN|IF}} {{Cl|MID$ (function)|MID$}}(fFilter$, R, 1) = "|" {{Cl|THEN}} {{Cl|MID$}}(fFilter$, R, 1) = {{Cl|CHR$}}(0)
{{Cl|NEXT}} R
fFilter$ = fFilter$ + {{Cl|CHR$}}(0)

lpstrFile$ = {{Cl|STRING$}}(2048, 0) ' For the returned file name
lpstrDefExt$ = {{Cl|STRING$}}(10, 0) ' Extension will not be added when this is not specified
OpenCall.lStructSize = {{Cl|LEN}}(OpenCall)
OpenCall.hwndOwner = hWnd&
OpenCall.lpstrFilter = {{Cl|_OFFSET (function)|_OFFSET}}(fFilter$)
OpenCall.nFilterIndex = FilterIndex
OpenCall.lpstrFile = {{Cl|_OFFSET (function)|_OFFSET}}(lpstrFile$)
OpenCall.nMaxFile = {{Cl|LEN}}(lpstrFile$) - 1
OpenCall.lpstrFileTitle = OpenCall.lpstrFile
OpenCall.nMaxFileTitle = OpenCall.nMaxFile
OpenCall.lpstrInitialDir = {{Cl|_OFFSET (function)|_OFFSET}}(InitialDir$)
OpenCall.lpstrTitle = {{Cl|_OFFSET (function)|_OFFSET}}(Title$)
OpenCall.lpstrDefExt = {{Cl|_OFFSET (function)|_OFFSET}}(lpstrDefExt$)
OpenCall.flags = Flags&

Result = GetOpenFileNameA&(OpenCall) '            Do Open File dialog call!

{{Cl|IF...THEN|IF}} Result {{Cl|THEN}}   ' Trim the remaining zeros
  GetOpenFileName$ = {{Cl|LEFT$}}(lpstrFile$, {{Cl|INSTR}}(lpstrFile$, {{Cl|CHR$}}(0)) - 1)
  Flags& = OpenCall.flags
  FilterIndex = OpenCall.nFilterIndex
{{Cl|END IF}}

{{Cl|END FUNCTION}}

{{Cl|FUNCTION}} GetSaveFileName$ (Title$, InitialDir$, Filter$, FilterIndex, Flags&, hWnd&)
'  Title$      - The dialog title.
'  InitialDir$ - If this left blank, it will use the directory where the last opened file is
'     located. Specify ".\" if you want to always use the current directory.
'  Filter$     - File filters separated by pipes (|) in the same format as VB6 common dialogs.
'  FilterIndex - The initial file filter to use. Will be altered by user during the call.
'  Flags&      - Dialog flags. Will be altered by the user during the call.
'  hWnd&       - Your program's window handle that should be aquired by the FindWindow function.

' Returns: Blank when cancel is clicked otherwise, the file name entered by the user.
' FilterIndex and Flags& will be changed depending on the user's selections.

{{Cl|DIM}} SaveCall {{Cl|AS}} FILEDIALOGTYPE  ' Needed for dialog call

fFilter$ = Filter$
{{Cl|FOR...NEXT|FOR}} R = 1 {{Cl|TO}} {{Cl|LEN}}(fFilter$)  ' Replace the pipes with zeros
  {{Cl|IF...THEN|IF}} {{Cl|MID$ (function)|MID$}}(fFilter$, R, 1) = "|" {{Cl|THEN}} {{Cl|MID$}}(fFilter$, R, 1) = {{Cl|CHR$}}(0)
{{Cl|NEXT}} R
fFilter$ = fFilter$ + {{Cl|CHR$}}(0)

lpstrFile$ = {{Cl|STRING$}}(2048, 0) ' For the returned file name
lpstrDefExt$ = {{Cl|STRING$}}(10, 0) ' Extension will not be added when this is not specified
SaveCall.lStructSize = {{Cl|LEN}}(SaveCall)
SaveCall.hwndOwner = hWnd&
SaveCall.lpstrFilter = {{Cl|_OFFSET (function)|_OFFSET}}(fFilter$)
SaveCall.nFilterIndex = FilterIndex
SaveCall.lpstrFile = {{Cl|_OFFSET (function)|_OFFSET}}(lpstrFile$)
SaveCall.nMaxFile = {{Cl|LEN}}(lpstrFile$) - 1
SaveCall.lpstrFileTitle = SaveCall.lpstrFile
SaveCall.nMaxFileTitle = SaveCall.nMaxFile
SaveCall.lpstrInitialDir = {{Cl|_OFFSET (function)|_OFFSET}}(InitialDir$)
SaveCall.lpstrTitle = {{Cl|_OFFSET (function)|_OFFSET}}(Title$)
SaveCall.lpstrDefExt = {{Cl|_OFFSET (function)|_OFFSET}}(lpstrDefExt$)
SaveCall.flags = Flags&

Result& = GetSaveFileNameA&(SaveCall) ' Do dialog call!

{{Cl|IF...THEN|IF}} Result& {{Cl|THEN}}  ' Trim the remaining zeros
  GetSaveFileName$ = {{Cl|LEFT$}}(lpstrFile$, {{Cl|INSTR}}(lpstrFile$, {{Cl|CHR$}}(0)) - 1)
  Flags& = SaveCall.flags
  FilterIndex = SaveCall.nFilterIndex
{{Cl|END IF}}
{{Cl|END FUNCTION}}
{{CodeEnd}}
{{Small|Code courtesy of Jobert14}}
: ''Note:'' The Open and Save Dialog boxes get user selections and do not actually open or create a file! Your program must do that.

<center>'''[http://msdn.microsoft.com/en-us/library/aa155724(v=office.10).aspx Microsoft MSDN]'''


'''[http://msdn.microsoft.com/en-us/library/aa259317(v=vs.60).aspx Common Dialog Flag Constants]'''</center>

:::::In VB6, variable-length strings in user [[TYPE]]s are actually pointer [[_OFFSET]]s to those strings.

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== File Times ==

{{CodeStart}}
{{Cl|CONST}} GENERIC_READ = -{{Cl|&H}}80000000
{{Cl|CONST}} GENERIC_WRITE = {{Cl|&H}}40000000
{{Cl|CONST}} FILE_SHARE_READ = {{Cl|&H}}1
{{Cl|CONST}} FILE_SHARE_WRITE = {{Cl|&H}}2
{{Cl|CONST}} OPEN_EXISTING = {{Cl|&H}}3
{{Cl|CONST}} INVALID_HANDLE_VALUE = -1

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
{{Cl|FUNCTION}} CreateFileA%& ({{Cl|BYVAL}} lpFileName {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} dwDesiredAccess {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, _
{{Cl|BYVAL}} dwShareMode {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, {{Cl|BYVAL}} lpSecurityAttributes {{Cl|AS}} {{Cl|_OFFSET}}, _
{{Cl|BYVAL}} dwCreationDisposition {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, {{Cl|BYVAL}} dwFlagsAndAttributes {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, _
{{Cl|BYVAL}} hTemplateFile {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} CloseHandle& ({{Cl|BYVAL}} hObject {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} GetFileTime& ({{Cl|BYVAL}} hFile {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpCreationTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpLastAccessTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpLastWriteTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} SetFileTime& ({{Cl|BYVAL}} hFile {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpCreationTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpLastAccessTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpLastWriteTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} FileTimeToLocalFileTime& ({{Cl|BYVAL}} lpFileTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpLocalFileTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} LocalFileTimeToFileTime& ({{Cl|BYVAL}} lpLocalFileTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpFileTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} FileTimeToSystemTime& ({{Cl|BYVAL}} lpFileTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpSystemTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} SystemTimeToFileTime& ({{Cl|BYVAL}} lpSystemTime {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpFileTime {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|FUNCTION}} GetLastError& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|TYPE}} FILETIME
  dwLowDateTime {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
  dwHighDateTime {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|TYPE}} SYSTEMTIME
  wYear {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wMonth {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wDayOfWeek {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wDay {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wHour {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wMinute {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wSecond {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
  wMilliseconds {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DIM}} CreateDate {{Cl|AS}} FILETIME
{{Cl|DIM}} ModifyDate {{Cl|AS}} FILETIME
{{Cl|DIM}} AccessDate {{Cl|AS}} FILETIME

{{Cl|DIM}} systime {{Cl|AS}} SYSTEMTIME

{{Cl|DIM}} FileName {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} FileHandle {{Cl|AS}} {{Cl|_OFFSET}}

FileName = "readme.txt" + {{Cl|CHR$}}(0) '<<<<<< Existing file in QB64 folder. Use existing file path!

FileHandle = CreateFileA%&({{Cl|_OFFSET (function)|_OFFSET}}(FileName), GENERIC_{{Cl|READ}}, FILE_SHARE_{{Cl|READ}} {{Cl|OR (boolean)|OR}} FILE_SHARE_{{Cl|WRITE}}, 0, {{Cl|OPEN}}_EXISTING, 0, 0)
{{Cl|IF...THEN|IF}} FileHandle <> INVALID_HANDLE_VALUE {{Cl|THEN}}
  {{Cl|IF...THEN|IF}} GetFileTime&(FileHandle, {{Cl|_OFFSET (function)|_OFFSET}}(CreateDate), {{Cl|_OFFSET (function)|_OFFSET}}(ModifyDate), {{Cl|_OFFSET (function)|_OFFSET}}(AccessDate)) {{Cl|THEN}}
    {{Cl|PRINT}} {{Cl|HEX$}}(CreateDate.dwLowDateTime) + {{Cl|HEX$}}(CreateDate.dwHighDateTime)
    {{Cl|PRINT}} {{Cl|HEX$}}(ModifyDate.dwLowDateTime) + {{Cl|HEX$}}(ModifyDate.dwHighDateTime)
    {{Cl|PRINT}} {{Cl|HEX$}}(AccessDate.dwLowDateTime) + {{Cl|HEX$}}(AccessDate.dwHighDateTime)
    {{Cl|PRINT}}
    {{Cl|IF...THEN|IF}} FileTimeToSystemTime&({{Cl|_OFFSET (function)|_OFFSET}}(CreateDate), {{Cl|_OFFSET (function)|_OFFSET}}(systime)) {{Cl|THEN}}
      {{Cl|PRINT}} "Creation time, in GMT, in decimal:"
      {{Cl|PRINT}} "Year:"; systime.wYear
      {{Cl|PRINT}} "Month:"; systime.wMonth, "("; {{Cl|MID$ (function)|MID$}}("JanFebMarAprMayJunJulAugSepOctNovDec", (systime.wMonth * 3) - 2, 3); ")"
      {{Cl|PRINT}} "DayOfWeek:"; systime.wDayOfWeek, "("; {{Cl|MID$ (function)|MID$}}("SunMonTueWedThuFriSat", (systime.wDayOfWeek * 3) + 1, 3); ")"
      {{Cl|PRINT}} "Day"; systime.wDay
      {{Cl|PRINT}} "Hour"; systime.wHour
      {{Cl|PRINT}} "Minute"; systime.wMinute
      {{Cl|PRINT}} "Second"; systime.wSecond
      {{Cl|PRINT}} "Milliseconds"; systime.wMilliseconds
    {{Cl|ELSE}}
      {{Cl|PRINT}} "FileTimeToSystemTime failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError&))
    {{Cl|END IF}}
  {{Cl|ELSE}}
    {{Cl|PRINT}} "GetFileTime failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError&))
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} CloseHandle&(FileHandle) = 0 {{Cl|THEN}}
    {{Cl|PRINT}} "CloseHandle failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError&))
    {{Cl|END}}
  {{Cl|END IF}}
{{Cl|ELSE}}
  {{Cl|PRINT}} "CreateFileA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError&))
  {{Cl|END}}
{{Cl|END IF}}
{{Cl|END}}
{{CodeEnd}}
{{Small|Code courtesy of Michael Calkins}}
<center>Use your own existing file name and path in this procedure.</center>


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Focus ==

: '''Sets Focus on program with ''SetForegroundWindow'' after maximizing a minimized program when Shift+A is pressed.''' (See [[Windows Libraries#Top_Most_Window|Top Most Window]])
{{CodeStart}}
'Uses GetKeyState Win API to monitor a Key state.
'This demo will maximize the window and focus on program when Shift+A is pressed.

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) 'find process handle by title
  {{Cl|FUNCTION}} GetKeyState% ({{Cl|BYVAL}} nVirtKey {{Cl|AS}} {{Cl|LONG}}) 'Windows virtual key presses
  {{Cl|FUNCTION}} ShowWindow& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} nCmdShow {{Cl|AS}} {{Cl|LONG}}) 'maximize process
  {{Cl|FUNCTION}} GetForegroundWindow%& 'find currently focused process handle
  {{Cl|FUNCTION}} SetForegroundWindow& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}}) 'set foreground window process(focus)
{{Cl|DECLARE LIBRARY|END DECLARE}}

title$ = "Cheapo Hotkey (Shift+A)" 'title of program window
{{Cl|_TITLE}} title$ 'set program title
hwnd%& = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, title$ + {{Cl|CHR$}}(0)) 'find this program's process handle

{{Cl|PRINT}} "Minimize window, click another then Press Shift+A to bring it back up."

'=== below minimizes it for you
{{Cl|_DELAY}} 4
x& = ShowWindow&(hwnd%&, 2)
'===========================

DO
  {{Cl|IF...THEN|IF}} GetKeyState(16) < 0 {{Cl|AND (boolean)|AND}} GetKeyState({{Cl|ASC (function)|ASC}}("A")) < 0 {{Cl|THEN}} '<==== Shift+A
    FGwin%& = GetForegroundWindow%& 'get current process in focus
    {{Cl|PRINT}} "Program Handle:"; hwnd%&; "Focus handle:"; FGwin%&

    y& = ShowWindow&(hwnd%&, 1) 'maximize minimized program

    {{Cl|IF...THEN|IF}} FGwin%& <> hwnd%& {{Cl|THEN}} z& = SetForegroundWindow&(hwnd%&) 'set focus when necessary

    {{Cl|PRINT}} "That is all. Return values:"; x&; y&; z&

    'PUT PROGRAM CODE OR SUB CALLS HERE!
    '=== below minimizes it for you again after code is done
    '{{Cl|_DELAY}} 4
    'x& = ShowWindow&(hwnd%&, 2)
    '===========================
    {{Cl|_DELAY}} 5: {{Cl|END}} 'delay allows user to not minimize the window
  {{Cl|END IF}}

  {{Cl|_LIMIT}} 30 'save CPU usage while waiting for key press

{{Cl|LOOP}}
{{CodeEnd}}
{{Small|Adapted by Ted Weissgerber from code by Dav}}
<center>The ''[[Windows Libraries#Window_Focus|GetForegroundWindow]]'' function finds the process currently in focus. See: [[Windows Libraries#Hot_Keys_(maximize)|Hot Keys for Windows Virtual Keys]]</center>


: '''Always brings unfocused or minimized program to the top with focus when Shift+A hotkey combination is pressed.'''
{{CodeStart}}
'===========
'HOTKEYS.BAS
'===========
'Windows Hotkey example.
'This demo sets Shift+A hotkey to maximize the program window when minimized.
'Returns focus to the program.
'Coded by Dav JULY/2012


{{Cl|DECLARE LIBRARY|DECLARE CUSTOMTYPE LIBRARY}}
  {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$)
  {{Cl|FUNCTION}} ShowWindow& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nCmdShow {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} SendMessageA& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} wMsg {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} wParam {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} lParam {{Cl|AS}} {{Cl|LONG}})
  {{Cl|FUNCTION}} DefWindowProcA& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} wMsg {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} wParam {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} lParam {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|_TITLE}} "My Focus Program"
hwnd = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "My Focus Program" + {{Cl|CHR$}}(0)) 'get Windows program ID by title

{{Cl|CONST}} WM_SETHOTKEY = {{Cl|&H}}32
{{Cl|CONST}} WM_SHOWWINDOW = {{Cl|&H}}18
'SendMessage function key combination values
{{Cl|CONST}} HK_SHIFT = {{Cl|&H}}100 'NOTE: Send Message values are different than HotKey
{{Cl|CONST}} HK_CTRL = {{Cl|&H}}200  'All other keys are the same as the HotKey values.
{{Cl|CONST}} HK_ALT = {{Cl|&H}}400

{{Cl|PRINT}} "Press Shift+A to maximize or bring this window to top..."
{{Cl|_DELAY}} 3

'=== Tell windows what hotkey you want to use.
hot& = SendMessageA&(hwnd, WM_SETHOTKEY, HK_SHIFT + ASC("A"), 0) 'use uppercase second key
{{Cl|PRINT}} hot&;
'=== See if hotkey set ok...
{{Cl|IF...THEN|IF}} hot& <> 1 {{Cl|THEN}}
  {{Cl|PRINT}} "Hotkey not set." + "Error: "; hot&
  {{Cl|END}}
{{Cl|END IF}}

'===  minimize program with this
'a& = ShowWindow&(hwnd, 6)

'=== Below tells Windows what to do when hotkey is pressed.
'===(it maximizes the program window and returns focus over and over).
top& = DefWindowProcA&(hwnd, WM_SHOWWINDOW, 0, 0)

{{Cl|DO...LOOP|DO}}: {{Cl|_LIMIT}} 1
  'do your program stuff here....
  {{Cl|PRINT}} hot&; top&;
{{Cl|LOOP}} {{Cl|UNTIL}} {{Cl|INKEY$}} = {{Cl|CHR$}}(27)
{{Cl|END}}
{{CodeEnd}}
{{Small|Adapted from code by Dav}}
: '''Note:''' The ''SetHotKey'' message tells the designated Windows program ID when to do ''DefWondowProcA'' to focus the window.

<center>'''This can also focus on other program IDs! See also: [[Windows Libraries#Hot_Keys_(maximize)|Hot Keys for Windows Virtual Keys]]'''</center>


<center>Note: Minimized programs will always lose focus when minimized unless clicked in taskbar.</center>

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Folder Dialog Box ==

: The SHBrowseForFolder function receives information about the folder selected by the user in Windows XP to 7.
{{CodeStart}}
{{Cl|DECLARE LIBRARY|DECLARE CUSTOMTYPE LIBRARY}}
    {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|_TITLE}} "Super Window"
hwnd& = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "Super Window" + {{Cl|CHR$}}(0))

{{Cl|TYPE}} BROWSEINFO  'typedef struct _browseinfo 'Microsoft MSDN
  hwndOwner {{Cl|AS}} {{Cl|LONG}} '              '  HWND
  pidlRoot {{Cl|AS}} {{Cl|_OFFSET}} '             '  PCIDLIST_ABSOLUTE
  pszDisplayName {{Cl|AS}} {{Cl|_OFFSET}} '      '  LPTSTR
  lpszTitle {{Cl|AS}} {{Cl|_OFFSET}} '           '  LPCTSTR
  ulFlags {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}        '  UINT
  lpfn {{Cl|AS}} {{Cl|_OFFSET}} '                '  BFFCALLBACK
  lParam {{Cl|AS}} {{Cl|_OFFSET}} '              '  LPARAM
  iImage {{Cl|AS}} {{Cl|LONG}} '                 '  int
{{Cl|END}} {{Cl|TYPE}}  'BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "shell32"
  {{Cl|FUNCTION}} SHBrowseForFolder%& (x {{Cl|AS}} BROWSEINFO) 'Microsoft MSDN
  {{Cl|SUB}} SHGetPathFromIDList ({{Cl|BYVAL}} lpItem {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} szDir {{Cl|AS}} {{Cl|_OFFSET}}) 'Microsoft MSDN
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} b {{Cl|AS}} BROWSEINFO
b.hwndOwner = hwnd
{{Cl|DIM}} s {{Cl|AS}} {{Cl|STRING}} * 1024
b.pszDisplayName = {{Cl|_OFFSET (function)|_OFFSET}}(s$)
a$ = "Choose a folder!!!" + {{Cl|CHR$}}(0)
b.lpszTitle = {{Cl|_OFFSET (function)|_OFFSET}}(a$)
{{Cl|DIM}} o {{Cl|AS}} {{Cl|_OFFSET}}
o = SHBrowseForFolder(b)
{{Cl|IF...THEN|IF}} o {{Cl|THEN}}
    {{Cl|PRINT}} {{Cl|LEFT$}}(s$, {{Cl|INSTR}}(s$, {{Cl|CHR$}}(0)) - 1)
    {{Cl|DIM}} s2 {{Cl|AS}} {{Cl|STRING}} * 1024
    SHGetPathFromIDList o, {{Cl|_OFFSET (function)|_OFFSET}}(s2$)
    {{Cl|PRINT}} {{Cl|LEFT$}}(s2$, {{Cl|INSTR}}(s2$, {{Cl|CHR$}}(0)) - 1)
{{Cl|ELSE}}
    {{Cl|PRINT}} "Cancel?"
{{Cl|END IF}}
{{CodeEnd}}
{{Small|Code by Galleon}}

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Font Dialog Box ==

<center>This dialog box does not return the actual font file name. Refer to the [[Windows Libraries#Registered_Fonts|Registered Fonts File]] procedure below this one.</center>
{{CodeStart}}
' Constants assigned to Flags. A LONG numerical suffix defines those constants as LONG
{{Cl|CONST}} CF_APPLY = {{Cl|&H}}200& '             Displays Apply button
{{Cl|CONST}} CF_ANSIONLY = {{Cl|&H}}400& '          list ANSI fonts only
{{Cl|CONST}} CF_BOTH = {{Cl|&H}}3& '                list both Screen and Printer fonts
{{Cl|CONST}} CF_EFFECTS = {{Cl|&H}}100&  '          Display Underline and Strike Through boxes
{{Cl|CONST}} CF_ENABLEHOOK = {{Cl|&H}}8& '          set hook to custom template
{{Cl|CONST}} CF_ENABLETEMPLATE = {{Cl|&H}}10& '     enable custom template
{{Cl|CONST}} CF_ENABLETEMPLATEHANDLE = {{Cl|&H}}20&
{{Cl|CONST}} CF_FIXEDPITCHONLY = {{Cl|&H}}4000&  '  list only fixed-pitch fonts
{{Cl|CONST}} CF_FORCEFONTEXIST = {{Cl|&H}}10000& '  indicate error when font not listed is chosen
{{Cl|CONST}} CF_INACTIVEFONTS = {{Cl|&H}}2000000& ' display hidden fonts in Win 7 only
{{Cl|CONST}} CF_INITTOLOGFONTSTRUCT = {{Cl|&H}}40& 'use the structure pointed to by the lpLogFont member
{{Cl|CONST}} CF_LIMITSIZE = {{Cl|&H}}2000& '        select font sizes only within nSizeMin and nSizeMax members
{{Cl|CONST}} CF_NOOEMFONTS = {{Cl|&H}}800& '        should not allow vector font selections
{{Cl|CONST}} CF_NOFACESEL = {{Cl|&H}}80000& '       prevent displaying initial selection in font name combo box.
{{Cl|CONST}} CF_NOSCRIPTSEL = {{Cl|&H}}800000& '    Disables the Script combo box
{{Cl|CONST}} CF_NOSIMULATIONS = {{Cl|&H}}1000& '    Disables selection of font simulations
{{Cl|CONST}} CF_NOSIZESEL = {{Cl|&H}}200000&  '     Disables Point Size selection
{{Cl|CONST}} CF_NOSTYLESEL = {{Cl|&H}}100000& '     Disables Style selection
{{Cl|CONST}} CF_NOVECTORFONTS = {{Cl|&H}}800&
{{Cl|CONST}} CF_NOVERTFONTS = {{Cl|&H}}1000000&
{{Cl|CONST}} CF_OEMTEXT = {{Cl|&H}}7&
{{Cl|CONST}} CF_PRINTERFONTS = {{Cl|&H}}2& '        list fonts only supported by printer associated with the device
{{Cl|CONST}} CF_SCALABLEONLY = {{Cl|&H}}20000& '    select only vector fonts, scalable printer fonts, and TrueType fonts
{{Cl|CONST}} CF_SCREENFONTS = {{Cl|&H}}1&  '        lists only the screen fonts supported by system
{{Cl|CONST}} CF_SCRIPTSONLY = {{Cl|&H}}400& '       lists all non-OEM, Symbol and ANSI sets only
{{Cl|CONST}} CF_SELECTSCRIPT = {{Cl|&H}}400000&  '  can only use set specified in the Scripts combo box
{{Cl|CONST}} CF_SHOWHELP = {{Cl|&H}}4&  '           displays Help button reference
{{Cl|CONST}} CF_TTONLY = {{Cl|&H}}40000&  '         True Type only
{{Cl|CONST}} CF_USESTYLE = {{Cl|&H}}80& '           copies style data for the user's selection to lpszStyle buffer
{{Cl|CONST}} CF_WYSIWYG = {{Cl|&H}}8000& '          only list fonts available on both the printer and display
' Font Types returned by nFontType
{{Cl|CONST}} BOLD_FONTTYPE = {{Cl|&H}}100&
{{Cl|CONST}} ITALIC_FONTTYPE = {{Cl|&H}}200&
{{Cl|CONST}} PRINTER_FONTTYPE = {{Cl|&H}}4000&
{{Cl|CONST}} REGULAR_FONTTYPE = {{Cl|&H}}400&
{{Cl|CONST}} SCREEN_FONTTYPE = {{Cl|&H}}2000&
{{Cl|CONST}} SIMULATED_FONTTYPE = {{Cl|&H}}8000&
' Font Weights assigned to lfWeight
{{Cl|CONST}} FW_DONTCARE = 0
{{Cl|CONST}} FW_THIN = 100
{{Cl|CONST}} FW_ULTRALIGHT = 200
{{Cl|CONST}} FW_LIGHT = 300
{{Cl|CONST}} FW_REGULAR = 400
{{Cl|CONST}} FW_MEDIUM = 500
{{Cl|CONST}} FW_SEMIBOLD = 600
{{Cl|CONST}} FW_BOLD = 700
{{Cl|CONST}} FW_ULTRABOLD = 800
{{Cl|CONST}} FW_HEAVY = 900

{{Cl|CONST}} DEFAULT_CHARSET = 1
{{Cl|CONST}} LF_DEFAULT = 0
{{Cl|CONST}} FF_ROMAN = 16
{{Cl|CONST}} LF_FACESIZE = 32
{{Cl|CONST}} GMEM_MOVEABLE = {{Cl|&H}}2
{{Cl|CONST}} GMEM_ZEROINIT = {{Cl|&H}}40
'-------------------------------------------------------------------------------------------

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} WindowName {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "comdlg32"
  {{Cl|FUNCTION}} ChooseFontA& ({{Cl|BYVAL}} lpcf {{Cl|AS}} {{Cl|_OFFSET}})
  {{Cl|FUNCTION}} CommDlgExtendedError& () '                'dialog box error checking procedure
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|TYPE}} CHOOSEFONT
  lStructSize {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
  hwndOwner {{Cl|AS}} {{Cl|_OFFSET}}
  HDC {{Cl|AS}} {{Cl|_OFFSET}}
  lpLogFont {{Cl|AS}} {{Cl|_OFFSET}}
  iPointSize {{Cl|AS}} {{Cl|LONG}}
  Flags {{Cl|AS}} {{Cl|LONG}}
  rgbColors {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
  lCustData {{Cl|AS}} {{Cl|_OFFSET}}
  lpfnHook {{Cl|AS}} {{Cl|_OFFSET}}
  lpTemplateName {{Cl|AS}} {{Cl|_OFFSET}}
  hInstance {{Cl|AS}} {{Cl|_OFFSET}}
  lpszStyle {{Cl|AS}} {{Cl|_OFFSET}}
  nFontType {{Cl|AS}} {{Cl|LONG}} '  if used as Unsigned Integer add Integer padder below
  'padder {{Cl|AS}} {{Cl|INTEGER}} ' use only when nFontType is designated as Unsigned Integer
  nSizeMin {{Cl|AS}} {{Cl|LONG}}
  nSizeMax {{Cl|AS}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|TYPE}} LOGFONT
  lfHeight {{Cl|AS}} {{Cl|LONG}}
  lfWidth {{Cl|AS}} {{Cl|LONG}}
  lfEscapement {{Cl|AS}} {{Cl|LONG}}
  lfOrientation {{Cl|AS}} {{Cl|LONG}}
  lfWeight {{Cl|AS}} {{Cl|LONG}}
  lfItalic {{Cl|AS}} {{Cl|_BYTE}} '    not 0 when user selected
  lfUnderline {{Cl|AS}} {{Cl|_BYTE}} ' not 0 when user selected
  lfStrikeOut {{Cl|AS}} {{Cl|_BYTE}} ' not 0 when user selected
  lfCharSet {{Cl|AS}} {{Cl|_BYTE}}
  lfOutPrecision {{Cl|AS}} {{Cl|_BYTE}}
  lfClipPrecision {{Cl|AS}} {{Cl|_BYTE}}
  lfQuality {{Cl|AS}} {{Cl|_BYTE}}
  lfPitchAndFamily {{Cl|AS}} {{Cl|_BYTE}}
  lfFaceName {{Cl|AS}} {{Cl|STRING}} * 32 'contains name listed in dialog
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DIM}} hWnd {{Cl|AS}} {{Cl|_OFFSET}} 'must {{Cl|DIM}} or hWnd won't work
{{Cl|DIM}} Title {{Cl|AS}} {{Cl|STRING}} 'keeps Dialog with program window

{{Cl|SCREEN}} {{Cl|_NEWIMAGE}}(640, 480, 12) '32 bit, 16 or 256 color screen modes
Title$ = "Choose Font Dialog"
{{Cl|_TITLE}} Title$ 'set Title of program
{{Cl|_DELAY}} 1
hWnd = {{Cl|_WINDOWHANDLE}} 'FindWindowA%&(0, {{Cl|_OFFSET (function)|_OFFSET}}(Title)) 'get window handle

Font$ = ShowFont$(hWnd) '           call Dialog Box and get the font selection
{{Cl|PRINT}} Font$, {{Cl|HEX$}}(FontColor&), FontType$; FontEff$, PointSize& 'other values {{Cl|SHARED}} by function
{{Cl|COLOR}} FontColor&: {{Cl|PRINT}} "Font Color Selected"
{{Cl|END}}

{{Cl|FUNCTION}} ShowFont$ (hWnd {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|DIM}} cf {{Cl|AS}} CHOOSEFONT
{{Cl|DIM}} lfont {{Cl|AS}} LOGFONT
{{Cl|SHARED}} FontColor&, FontType$, FontEff$, PointSize {{Cl|AS}} {{Cl|LONG}} 'shared with main program
lfont.lfHeight = LF_DEFAULT ' determine default height '       set dailog box defaults
lfont.lfWidth = LF_DEFAULT ' determine default width
lfont.lfEscapement = LF_DEFAULT ' angle between baseline and escapement vector
lfont.lfOrientation = LF_DEFAULT ' angle between baseline and orientation vector
lfont.lfWeight = FW_REGULAR ' normal weight i.e. not bold
lfont.lfCharSet = DEFAULT_CHARSET ' use default character set
lfont.lfOutPrecision = LF_DEFAULT ' default precision mapping
lfont.lfClipPrecision = LF_DEFAULT ' default clipping precision
lfont.lfQuality = LF_DEFAULT ' default quality setting
lfont.lfPitchAndFamily = LF_DEFAULT {{Cl|OR (boolean)|OR}} FF_ROMAN ' default pitch, proportional with serifs
lfont.lfFaceName = "Times New Roman" + {{Cl|CHR$}}(0) ' string must be null-terminated
cf.lStructSize = {{Cl|LEN}}(cf) ' size of structure
cf.hwndOwner = hWnd ' window opening the dialog box
'cf.HDC = Printer.hDC ' device context of default printer (using VB's mechanism)
cf.lpLogFont = {{Cl|_OFFSET (function)|_OFFSET}}(lfont)
cf.iPointSize = 120 ' 12 point font (in units of 1/10 point)
cf.Flags = CF_BOTH {{Cl|OR (boolean)|OR}} CF_EFFECTS {{Cl|OR (boolean)|OR}} CF_{{Cl|FOR...NEXT|FOR}}CEFONTEXIST {{Cl|OR (boolean)|OR}} CF_INITTOLOGFONTSTRUCT {{Cl|OR (boolean)|OR}} CF_LIMITSIZE
cf.rgbColors = {{Cl|_RGB}}(0, 0, 0) ' black
cf.nFontType = REGULAR_FONTTYPE ' regular font type i.e. not bold or anything
cf.nSizeMin = 10 ' minimum point size
cf.nSizeMax = 72 ' maximum point size

{{Cl|IF...THEN|IF}} ChooseFontA&({{Cl|_OFFSET (function)|_OFFSET}}(cf)) <> 0 {{Cl|THEN}} '    'Initiate Dialog and Read user selections
  ShowFont = {{Cl|LEFT$}}(lfont.lfFaceName, {{Cl|INSTR}}(lfont.lfFaceName, {{Cl|CHR$}}(0)) - 1)
  'returns closest color attribute or 32 bit value and swaps red and blue color values
  FontColor& = {{Cl|_RGB}}({{Cl|_BLUE32}}(cf.rgbColors), {{Cl|_GREEN32}}(cf.rgbColors), {{Cl|_RED32}}(cf.rgbColors))
  {{Cl|IF...THEN|IF}} cf.nFontType {{Cl|AND (boolean)|AND}} BOLD_FONTTYPE {{Cl|THEN}} FontType$ = "Bold"
  {{Cl|IF...THEN|IF}} cf.nFontType {{Cl|AND (boolean)|AND}} ITALIC_FONTTYPE {{Cl|THEN}} FontType$ = FontType$ + "Italic"
  {{Cl|IF...THEN|IF}} cf.nFontType {{Cl|AND (boolean)|AND}} REGULAR_FONTTYPE {{Cl|THEN}} FontType$ = "Regular"
  {{Cl|IF...THEN|IF}} lfont.lfUnderline {{Cl|THEN}} FontEff$ = "Underline"
  {{Cl|IF...THEN|IF}} lfont.lfStrikeOut {{Cl|THEN}} FontEff$ = FontStyle$ + "Strikeout"
  PointSize = cf.iPointSize \ 10
{{Cl|ELSE}}
  {{Cl|IF...THEN|IF}} CommDlgExtendedError& {{Cl|THEN}}
    {{Cl|PRINT}} "ChooseFontA failed. Error: 0x"; {{Cl|LCASE$}}({{Cl|HEX$}}(CommDlgExtendedError&))
  {{Cl|ELSE}}: {{Cl|PRINT}} "Entry was cancelled!"
  {{Cl|END IF}}
{{Cl|END IF}}
{{Cl|END FUNCTION}}
{{CodeEnd}}
{{Small|Code by Michael Calkins and Ted Weissgerber}}
<center>'''Warning! This dialog box may error for no apparent reason! See [http://msdn.microsoft.com/en-us/library/windows/desktop/ms646916(v=vs.85).aspx CommDlgExtendedError] for more info!'''</center>


: ''Snippet:'' Shows how to compare a Font Dialog Box request with [[STRING]] file data created by the [[Windows Libraries#Registered_Fonts|Registry Font Library]] below:

{{TextStart}}' procedure assumes that all fonts have been loaded into an array as below:
RegFont$(1) = "Times New Roman (TrueType) = TIMES.TTF" 'array simulates registry data from file
RegFont$(2) = "Times New Roman Bold (TrueType) = TIMESBD.TTF"
RegFont$(3) = "Times New Roman Bold Italic (TrueType) = TIMESBI.TTF"
RegFont$(4) = "Times New Roman Italic (TrueType) = TIMESI.TTF"
Font$ = "Times New Roman Bold Italic" 'font name returned by Font Dialog box
File$ = ""

{{Cb|FOR...NEXT|FOR}} n = 1 {{Cb|TO}} 4 'numFiles% 'actual number of font file registry records
{{Cb|IF...THEN|IF}} {{Cb|INSTR}}$(RegFont$(n), Font$) {{Cb|THEN}} 'check for match of Dialog Box font name "Times New Roman"
  FontFile$ = {{Cb|MID$ (function)|MID$}}(RegFont$(n), {{Cb|INSTR}}(RegFont$(n), "=") + 2)   'get each file name value
  {{Cb|SELECT CASE}} FontType$   'check for user requested font type to get file name
  {{Cb|CASE}} "Bold"
    {{Cb|IF...THEN|IF}} {{Cb|INSTR}}(RegFont$(n), "Bold") {{Cb|AND (boolean)|AND}} {{Cb|INSTR}}(RegFont$(n), "Italic") = 0 {{Cb|THEN}} File$ = FontFile$
  {{Cb|CASE}} "Italic"
    {{Cb|IF...THEN|IF}} {{Cb|INSTR}}(RegFont$(n), "Italic") {{Cb|AND (boolean)|AND}} {{Cb|INSTR}}(RegFont$(n), "Bold") = 0 {{Cb|THEN}} File$ = FontFile$
  {{Cb|CASE}} "BoldItalic"
    {{Cb|IF...THEN|IF}} {{Cb|INSTR}}(RegFont$(n), "Bold") {{Cb|AND (boolean)|AND}} {{Cb|INSTR}}(RegFont$(n), "Italic") {{Cb|THEN}} File$ = FontFile$
  {{Cb|CASE ELSE}} 'regular font as default
    {{Cb|IF...THEN|IF}} {{Cb|INSTR}}(RegFont$(n), "Bold") = 0 {{Cb|AND (boolean)|AND}} {{Cb|INSTR}}(RegFont$(n), "Italic") = 0 {{Cb|THEN}} File$ = FontFile$
  {{Cb|END SELECT}}
{{Cb|END IF}}
{{Cb|IF...THEN|IF}} {{Cb|LEN}}(File$) {{Cb|THEN}} {{Cb|EXIT FOR}}  'quit searching
{{Cb|NEXT}}
{{TextEnd}}
: ''Note:'' The Font Dialog name will not normally have descriptions such as Regular, Bold, Italics or (TrueType) so it ignores them.


<center>'''[http://www.functionx.com/win32/Lesson14.htm GDI Tools - Font Guidlines]'''</center>

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Registered Fonts ==

:The Registry lists the Font Names and associated TTF file names that are needed with the [[Windows Libraries#Font_Dialog_Box|Font Dialog Box]] in a program.
:The following program uses Registry functions from ''advapi32.dll'' to read the list of registered fonts and put them into a file.
{{CodeStart}}
' winreg.h
{{Cl|CONST}} HKEY_CLASSES_ROOT = {{Cl|&H}}80000000~&
{{Cl|CONST}} HKEY_CURRENT_USER = {{Cl|&H}}80000001~&
{{Cl|CONST}} HKEY_LOCAL_MACHINE = {{Cl|&H}}80000002~&
{{Cl|CONST}} HKEY_USERS = {{Cl|&H}}80000003~&
{{Cl|CONST}} HKEY_PERFORMANCE_DATA = {{Cl|&H}}80000004~&
{{Cl|CONST}} HKEY_CURRENT_CONFIG = {{Cl|&H}}80000005~&
{{Cl|CONST}} HKEY_DYN_DATA = {{Cl|&H}}80000006~&
{{Cl|CONST}} REG_OPTION_VOLATILE = 1
{{Cl|CONST}} REG_OPTION_NON_VOLATILE = 0
{{Cl|CONST}} REG_CREATED_NEW_KEY = 1
{{Cl|CONST}} REG_OPENED_EXISTING_KEY = 2

' '''http://msdn.microsoft.com/en-us/library/ms724884(v=VS.85).aspx'''
{{Cl|CONST}} REG_NONE = 0
{{Cl|CONST}} REG_SZ = 1
{{Cl|CONST}} REG_EXPAND_SZ = 2
{{Cl|CONST}} REG_BINARY = 3
{{Cl|CONST}} REG_DWORD_LITTLE_ENDIAN = 4  '   value is defined REG_DWORD in Windows header files
{{Cl|CONST}} REG_DWORD = 4 '                  32-bit number
{{Cl|CONST}} REG_DWORD_BIG_ENDIAN = 5 '       some UNIX systems support big-endian architectures
{{Cl|CONST}} REG_LINK = 6
{{Cl|CONST}} REG_MULTI_SZ = 7
{{Cl|CONST}} REG_RESOURCE_LIST = 8
{{Cl|CONST}} REG_FULL_RESOURCE_DESCRIPTOR = 9
{{Cl|CONST}} REG_RESOURCE_REQUIREMENTS_LIST = 10
{{Cl|CONST}} REG_QWORD_LITTLE_ENDIAN = 11  '  64-bit number in little-endian format
{{Cl|CONST}} REG_QWORD = 11 '                 64-bit number
{{Cl|CONST}} REG_NOTIFY_CHANGE_NAME = 1
{{Cl|CONST}} REG_NOTIFY_CHANGE_ATTRIBUTES = 2
{{Cl|CONST}} REG_NOTIFY_CHANGE_LAST_SET = 4
{{Cl|CONST}} REG_NOTIFY_CHANGE_SECURITY = 8

' '''http://msdn.microsoft.com/en-us/library/ms724878(v=VS.85).aspx'''
{{Cl|CONST}} KEY_ALL_ACCESS = {{Cl|&H}}F003F&
{{Cl|CONST}} KEY_CREATE_LINK = {{Cl|&H}}0020&
{{Cl|CONST}} KEY_CREATE_SUB_KEY = {{Cl|&H}}0004&
{{Cl|CONST}} KEY_ENUMERATE_SUB_KEYS = {{Cl|&H}}0008&
{{Cl|CONST}} KEY_EXECUTE = {{Cl|&H}}20019&
{{Cl|CONST}} KEY_NOTIFY = {{Cl|&H}}0010&
{{Cl|CONST}} KEY_QUERY_VALUE = {{Cl|&H}}0001&
{{Cl|CONST}} KEY_READ = {{Cl|&H}}20019&
{{Cl|CONST}} KEY_SET_VALUE = {{Cl|&H}}0002&
{{Cl|CONST}} KEY_WOW64_32KEY = {{Cl|&H}}0200&
{{Cl|CONST}} KEY_WOW64_64KEY = {{Cl|&H}}0100&
{{Cl|CONST}} KEY_WRITE = {{Cl|&H}}20006&

' winerror.h
' '''http://msdn.microsoft.com/en-us/library/ms681382(v=VS.85).aspx'''
{{Cl|CONST}} ERROR_SUCCESS = 0
{{Cl|CONST}} ERROR_FILE_NOT_FOUND = {{Cl|&H}}2&
{{Cl|CONST}} ERROR_INVALID_HANDLE = {{Cl|&H}}6&
{{Cl|CONST}} ERROR_MORE_DATA = {{Cl|&H}}EA&
{{Cl|CONST}} ERROR_NO_MORE_ITEMS = {{Cl|&H}}103&
'---------------------------------------------------------------------------------------------
' REGSAM is an ACCESS_MASK (winreg.h), which is a DWORD (winnt.h)

'Note: All of these functions, except RegCloseKey, have both ANSI (ending in A)
'and Unicode (ending in W) versions. I am not aware of any reason why both
'versions could not be used in the same program. To add the Unicode version,
'duplicate the function declaration, but change the ending A to W. Be sure that
'you know how to use the {{Cl|Unicode}} version! ANSI versions tested, sort of:

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "advapi32"

  ' '''http://msdn.microsoft.com/en-us/library/ms724897(v=VS.85).aspx'''
  {{Cl|FUNCTION}} RegOpenKeyExA& ({{Cl|BYVAL}} hKey {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpSubKey {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} ulOptions {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, {{Cl|BYVAL}} samDesired {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, {{Cl|BYVAL}} phkResult {{Cl|AS}} {{Cl|_OFFSET}})

  ' '''http://msdn.microsoft.com/en-us/library/ms724837(v=VS.85).aspx'''
  {{Cl|FUNCTION}} RegCloseKey& ({{Cl|BYVAL}} hKey {{Cl|AS}} {{Cl|_OFFSET}})

  ' '''http://msdn.microsoft.com/en-us/library/ms724865(v=VS.85).aspx'''
  {{Cl|FUNCTION}} RegEnumValueA& ({{Cl|BYVAL}} hKey {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} dwIndex {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, {{Cl|BYVAL}} lpValueName {{Cl|AS}} {{Cl|_OFFSET}},_
 {{Cl|BYVAL}} lpcchValueName {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpReserved {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpType {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpData {{Cl|AS}} {{Cl|_OFFSET}},_
 {{Cl|BYVAL}} lpcbData {{Cl|AS}} {{Cl|_OFFSET}})

{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} hKey {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|DIM}} Ky {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|DIM}} SubKey {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} Value {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} bData {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} t {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} dwType {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} numBytes {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} numTchars {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} l {{Cl|AS}} {{Cl|LONG}}
{{Cl|DIM}} dwIndex {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}

{{Cl|OPEN}} "F0NTList.INF" {{Cl|FOR}} {{Cl|OUTPUT}} {{Cl|AS}} #1  'create a new file for font data
{{Cl|PRINT}}
{{Cl|PRINT}} "This key lists the registered fonts available to all users:"
Ky = HKEY_LOCAL_MACHINE
SubKey = "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts" + {{Cl|CHR$}}(0)
Value = {{Cl|SPACE$}}(261) 'ANSI Value name limit 260 chars + 1 null
bData = {{Cl|SPACE$}}({{Cl|&H}}7FFF) 'arbitrary

l = RegOpenKeyExA(Ky, {{Cl|_OFFSET (function)|_OFFSET}}(SubKey), 0, KEY_READ, {{Cl|_OFFSET (function)|_OFFSET}}(hKey))
{{Cl|IF...THEN|IF}} l {{Cl|THEN}}
  {{Cl|PRINT}} "RegOpenKeyExA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(l))
{{Cl|ELSE}}
  {{Cl|PRINT}} whatKey$(Ky) + "\" + SubKey
  dwIndex = 0
  DO
    {{Cl|_DELAY}} .1
    numBytes = {{Cl|LEN}}(bData)
    numTchars = {{Cl|LEN}}(Value)
    l = RegEnumValueA(hKey, dwIndex, {{Cl|_OFFSET (function)|_OFFSET}}(Value), {{Cl|_OFFSET (function)|_OFFSET}}(numTchars), 0, {{Cl|_OFFSET (function)|_OFFSET}}(dwType), {{Cl|_OFFSET (function)|_OFFSET}}(bData), {{Cl|_OFFSET (function)|_OFFSET}}(numBytes))
    {{Cl|IF...THEN|IF}} l {{Cl|THEN}}
      {{Cl|IF...THEN|IF}} l <> ERROR_NO_MORE_ITEMS {{Cl|THEN}}
        {{Cl|PRINT}} "RegEnumValueA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(l))
      {{Cl|END IF}}
      {{Cl|EXIT DO}}
    {{Cl|ELSE}}
      {{Cl|PRINT}} whatType(dwType) + " " + {{Cl|LEFT$}}(Value, numTchars) + " = " + formatData(dwType, numBytes, bData)
      {{Cl|PRINT (file statement)|PRINT}} #1, {{Cl|LEFT$}}(Value, numTchars) + " = " + formatData(dwType, numBytes, bData)
    {{Cl|END IF}}
    dwIndex = dwIndex + 1
  {{Cl|LOOP}}
  {{Cl|CLOSE}} #1
  {{Cl|PRINT}} dwIndex; "Values."
  l = RegCloseKey(hKey)
  {{Cl|IF...THEN|IF}} l {{Cl|THEN}}
    {{Cl|PRINT}} "RegCloseKey failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(l))
    {{Cl|END}}
  {{Cl|END IF}}
{{Cl|END IF}}

{{Cl|END}}

{{Cl|FUNCTION}} whatType$ (dwType {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}})
{{Cl|SELECT CASE}} dwType
  {{Cl|CASE}} REG_SZ: whatType = "REG_SZ"
  {{Cl|CASE}} REG_EXPAND_SZ: whatType = "REG_EXPAND_SZ"
  {{Cl|CASE}} REG_BINARY: whatType = "REG_BINARY"
  {{Cl|CASE}} REG_DWORD: whatType = "REG_DWORD"
  {{Cl|CASE}} REG_DWORD_BIG_ENDIAN: whatType = "REG_DWORD_BIG_ENDIAN"
  {{Cl|CASE}} REG_LINK: whatType = "REG_LINK"
  {{Cl|CASE}} REG_MULTI_SZ: whatType = "REG_MULTI_SZ"
  {{Cl|CASE}} REG_RESOURCE_LIST: whatType = "REG_RESOURCE_LIST"
  {{Cl|CASE}} REG_FULL_RESOURCE_DESCRIPTOR: whatType = "REG_FULL_RESOURCE_DESCRIPTOR"
  {{Cl|CASE}} REG_RESOURCE_REQUIREMENTS_LIST: whatType = "REG_RESOURCE_REQUIREMENTS_LIST"
  {{Cl|CASE}} REG_QWORD: whatType = "REG_QWORD"
  {{Cl|CASE ELSE}}: whatType = "unknown"
{{Cl|END SELECT}}
{{Cl|END FUNCTION}}

{{Cl|FUNCTION}} whatKey$ (hKey {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|SELECT CASE}} hKey
  {{Cl|CASE}} HKEY_CLASSES_ROOT: whatKey = "HKEY_CLASSES_ROOT"
  {{Cl|CASE}} HKEY_CURRENT_USER: whatKey = "HKEY_CURRENT_USER"
  {{Cl|CASE}} HKEY_LOCAL_MACHINE: whatKey = "HKEY_LOCAL_MACHINE"
  {{Cl|CASE}} HKEY_USERS: whatKey = "HKEY_USERS"
  {{Cl|CASE}} HKEY_PERFORMANCE_DATA: whatKey = "HKEY_PERFORMANCE_DATA"
  {{Cl|CASE}} HKEY_CURRENT_CONFIG: whatKey = "HKEY_CURRENT_CONFIG"
  {{Cl|CASE}} HKEY_DYN_DATA: whatKey = "HKEY_DYN_DATA"
{{Cl|END SELECT}}
{{Cl|END FUNCTION}}

{{Cl|FUNCTION}} formatData$ (dwType {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, numBytes {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}, bData {{Cl|AS}} {{Cl|STRING}})
{{Cl|DIM}} t {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} ul {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} b {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|_BYTE}}
{{Cl|SELECT CASE}} dwType
  {{Cl|CASE}} REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
    formatData = {{Cl|LEFT$}}(bData, numBytes - 1)
  {{Cl|CASE}} REG_DWORD
    t = {{Cl|LCASE$}}({{Cl|HEX$}}({{Cl|CVL}}({{Cl|LEFT$}}(bData, 4))))
    formatData = "0x" + {{Cl|STRING$}}(8 - {{Cl|LEN}}(t), {{Cl|&H}}30) + t
  {{Cl|CASE ELSE}}
    {{Cl|IF...THEN|IF}} numBytes {{Cl|THEN}}
      b = {{Cl|ASC (function)|ASC}}({{Cl|LEFT$}}(bData, 1))
      {{Cl|IF...THEN|IF}} b < {{Cl|&H}}10 {{Cl|THEN}}
        t = t + "0" + {{Cl|LCASE$}}({{Cl|HEX$}}(b))
      {{Cl|ELSE}}
        t = t + {{Cl|LCASE$}}({{Cl|HEX$}}(b))
      {{Cl|END IF}}
    {{Cl|END IF}}
    {{Cl|FOR...NEXT|FOR}} ul = 2 {{Cl|TO}} numBytes
      b = {{Cl|ASC (function)|ASC}}({{Cl|MID$ (function)|MID$}}(bData, ul, 1))
      {{Cl|IF...THEN|IF}} b < {{Cl|&H}}10 {{Cl|THEN}}
        t = t + " 0" + {{Cl|LCASE$}}({{Cl|HEX$}}(b))
      {{Cl|ELSE}}
        t = t + " " + {{Cl|LCASE$}}({{Cl|HEX$}}(b))
      {{Cl|END IF}}
    {{Cl|NEXT}}
    formatData = t
{{Cl|END SELECT}}
{{Cl|END FUNCTION}}
{{CodeEnd}}
{{Small|Code courtesy of Michael Calkins}}
: ''Note:'' The names used in a Font Dialog Box and the actual file names are saved to the ''F0NTList.INF''(name uses zero) file to be compared with user entries. To check for ''Bold'' and ''Italics'' or combined types of font requests see [[Windows Libraries#Font_Dialog_Box|Font Dialog Box Library]] above.
<center>'''Note: The above procedure only reads the Registry. {{Text|Edit or alter the Registry at your own peril!|red}}'''</center>


<center>[[Windows Registry Access|Windows Registry Libraries]]</center>


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Game Pad ==
:Function ''joyGetPosEx'' allows for more buttons and dual analog multiple sticks
{{TextStart}}
{{Cb|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "winmm"
    {{Cb|FUNCTION}} joyGetNumDevs% () ' Number of joysticks supported on system
    {{Cb|FUNCTION}} joyGetPosEx& ({{Cb|BYVAL}} uJoyID {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, joyref {{Cb|AS}} {{Cb|LONG}})
{{Cb|END DECLARE}}

{{Cb|TYPE}} JOYINFOEX
    dwSize {{Cb|AS}} {{Cb|LONG}}
    dwFlags {{Cb|AS}} {{Cb|LONG}}
    dwXpos {{Cb|AS}} {{Cb|LONG}}
    dwYpos {{Cb|AS}} {{Cb|LONG}}
    dwZpos {{Cb|AS}} {{Cb|LONG}}
    dwRpos {{Cb|AS}} {{Cb|LONG}}
    dwUpos {{Cb|AS}} {{Cb|LONG}}
    dwVpos {{Cb|AS}} {{Cb|LONG}}
    dwButtons {{Cb|AS}} {{Cb|LONG}}
    dwButtonNumber {{Cb|AS}} {{Cb|LONG}}
    dwPOV {{Cb|AS}} {{Cb|LONG}}
    dwReserved1 {{Cb|AS}} {{Cb|LONG}}
    dwReserved2 {{Cb|AS}} {{Cb|LONG}}
{{Cb|END}} {{Cb|TYPE}}

{{Cb|DIM}} Joy1 {{Cb|AS}} JOYINFOEX
Joy1.dwSize = {{Cb|LEN}}(Joy1)

DO
    x& = joyGetPosEx(0, Joy1.dwSize)

    {{Cb|LOCATE}} 1, 1:
    {{Cb|PRINT}} Joy1.dwSize
    {{Cb|PRINT}} Joy1.dwFlags
    {{Cb|PRINT}} Joy1.dwXpos
    {{Cb|PRINT}} Joy1.dwYpos
    {{Cb|PRINT}} Joy1.dwZpos
    {{Cb|PRINT}} Joy1.dwRpos
    {{Cb|PRINT}} Joy1.dwUpos
    {{Cb|PRINT}} Joy1.dwVpos

{{Cb|LOOP}} {{Cb|UNTIL}} {{Cb|INKEY$}} <> ""
{{TextEnd}}
{{Small|Code courtesy of Unseenmachine}}

{{TextStart}}
{{Cb|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "winmm"
    {{Cb|FUNCTION}} joyGetNumDevs% () ' Number of joysticks supported on system
    {{Cb|FUNCTION}} joyGetPos& ({{Cb|BYVAL}} uJoyID {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, joyref {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|LONG}})
{{Cb|DECLARE LIBRARY|END DECLARE}}

{{Cb|TYPE}} JOYINFO
    wXpos {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|LONG}}
    wYpos {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|LONG}}
    wZpos {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|LONG}}
    wButtons {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|LONG}}
{{Cb|END}} {{Cb|TYPE}}

{{Cb|TYPE}} PadCalibration
    IsAnalog {{Cb|AS}} {{Cb|INTEGER}}
    XMin {{Cb|AS}} {{Cb|LONG}}
    YMin {{Cb|AS}} {{Cb|LONG}}
    XMax {{Cb|AS}} {{Cb|LONG}}
    YMax {{Cb|AS}} {{Cb|LONG}}
    XNorm {{Cb|AS}} {{Cb|LONG}}
    YNorm {{Cb|AS}} {{Cb|LONG}}
    Button1 {{Cb|AS}} {{Cb|INTEGER}}
    Button2 {{Cb|AS}} {{Cb|INTEGER}}
    Button3 {{Cb|AS}} {{Cb|INTEGER}}
    Button4 {{Cb|AS}} {{Cb|INTEGER}}
    Button5 {{Cb|AS}} {{Cb|INTEGER}}
    Button6 {{Cb|AS}} {{Cb|INTEGER}}
{{Cb|END}} {{Cb|TYPE}}

{{Cb|DIM}} MyJoyCal {{Cb|AS}} PadCalibration, MyJoy {{Cb|AS}} JOYINFO


'// Simple calibration.

{{Cb|PRINT}} "Press button 1 (A on XBox | X on PS3) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons > 0
MyJoyCal.Button1 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Press button 2 (B on XBox | Circle on PS3) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons <> 0
MyJoyCal.Button2 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Press button 3 (X on XBox | Square on PS3) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons <> 0
MyJoyCal.Button3 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Press button 4 (Y on XBox | Triangle on PS3) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons <> 0
MyJoyCal.Button4 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Press button 5 (R1) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons <> 0
MyJoyCal.Button5 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Press button 6 (L1) "
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons <> 0
MyJoyCal.Button6 = MyJoy.wButtons
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Leave the joystick in its central position and press button 1"
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons = MyJoyCal.Button1
MyJoyCal.XNorm = MyJoy.wXpos
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Push the joystick as far left as possible and press button 1"
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons = MyJoyCal.Button1
MyJoyCal.XMin = MyJoy.wXpos
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Push the joystick as far right as possible and press button 1"
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons = MyJoyCal.Button1
MyJoyCal.XMax = MyJoy.wXpos
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Push the joystick as far up as possible and press button 1"
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons = MyJoyCal.Button1
MyJoyCal.YMin = MyJoy.wXpos
{{Cb|SLEEP}} 1

{{Cb|PRINT}} "Push the joystick as far down as possible and press button 1"
DO
    d% = JoyButtons(0, MyJoy, MyJoyCal)
{{Cb|LOOP}} {{Cb|UNTIL}} MyJoy.wButtons = MyJoyCal.Button1
MyJoyCal.YMax = MyJoy.wXpos
{{Cb|SLEEP}} 1

{{Cb|CLS}}

'//How to get the gamepads status.

DO
    a% = StickXPos(0, MyJoy, MyJoyCal)
    b% = StickYPos(0, MyJoy, MyJoyCal)
    c% = StickZPos(0, MyJoy, MyJoyCal)
    d% = JoyButton1(0, MyJoy, MyJoyCal)
    e% = JoyButton2(0, MyJoy, MyJoyCal)
    f% = JoyButton3(0, MyJoy, MyJoyCal)
    g% = JoyButton4(0, MyJoy, MyJoyCal)
    h% = JoyButton5(0, MyJoy, MyJoyCal)
    i% = JoyButton6(0, MyJoy, MyJoyCal)

    {{Cb|LOCATE}} 1, 1: {{Cb|PRINT}} "X axis : ", MyJoy.wXpos
    {{Cb|PRINT}} "Y axis : ", MyJoy.wYpos
    {{Cb|PRINT}} "Z axis : ", MyJoy.wZpos
    {{Cb|PRINT}} "Button 1 : ", d%
    {{Cb|PRINT}} "Button 2 : ", e%
    {{Cb|PRINT}} "Button 3 : ", f%
    {{Cb|PRINT}} "Button 4 : ", g%
    {{Cb|PRINT}} "Button 5 : ", h%
    {{Cb|PRINT}} "Button 6 : ", i%

{{Cb|LOOP}} {{Cb|UNTIL}} {{Cb|INKEY$}} <> ""


'// Functions

{{Cb|FUNCTION}} StickXPos (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
StickXPos = Joyref.wXpos
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} StickYPos (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
StickYPos = Joyref.wYpos
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} StickZPos (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
StickZPos = Joyref.wZpos
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButtons (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
JoyButtons = Joyref.wButtons
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton1 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button1 {{Cb|THEN}}
    JoyButton1 = -1
{{Cb|ELSE}}
    JoyButton1 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton2 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button2 {{Cb|THEN}}
    JoyButton2 = -1
{{Cb|ELSE}}
    JoyButton2 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton3 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button3 {{Cb|THEN}}
    JoyButton3 = -1
{{Cb|ELSE}}
    JoyButton3 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton4 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button4 {{Cb|THEN}}
    JoyButton4 = -1
{{Cb|ELSE}}
    JoyButton4 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton5 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button5 {{Cb|THEN}}
    JoyButton5 = -1
{{Cb|ELSE}}
    JoyButton5 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}

{{Cb|FUNCTION}} JoyButton6 (Index {{Cb|AS}} {{Cb|_UNSIGNED}} {{Cb|INTEGER}}, Joyref {{Cb|AS}} JOYINFO, JoyCal {{Cb|AS}} PadCalibration)
x = joyGetPos(Index, Joyref.wXpos)
{{Cb|IF...THEN|IF}} Joyref.wButtons = JoyCal.Button6 {{Cb|THEN}}
    JoyButton6 = -1
{{Cb|ELSE}}
    JoyButton6 = 0
{{Cb|END IF}}
{{Cb|END FUNCTION}}
{{TextEnd}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Hot Keys (maximize) ==
: '''Maximizing a minimized program window not in focus using Shift + A as read by the Windows ''GetKeyState'' function.'''
{{CodeStart}}
'=================
'CHEAPO-HOTKEY.BAS
'=================
'Uses GetKeyState Win API to monitor a Key state.
'This demo will maximize the window when Shift+A is pressed at any time.

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} FindWindowA& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) 'handle by title
  {{Cl|FUNCTION}} GetKeyState% ({{Cl|BYVAL}} nVirtKey {{Cl|AS}} {{Cl|LONG}}) 'reads Windows key presses independently
  {{Cl|FUNCTION}} ShowWindow& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nCmdShow {{Cl|AS}} {{Cl|LONG}}) 'minimize or maximize
{{Cl|DECLARE LIBRARY|END DECLARE}}

title$ = "Cheapo Hotkey (Shift+A)" 'string variable avoids title typo's
{{Cl|_TITLE}} title$
hwnd& = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, title$ + {{Cl|CHR$}}(0))

{{Cl|PRINT}} "Minimize this window, then Press Shift+A to bring it back up."

'=== below minimizes it for you
'{{Cl|_DELAY}} 4
'x& = ShowWindow&(hwnd&, 2)
'===========================

DO
  {{Cl|IF...THEN|IF}} GetKeyState(16) < 0 {{Cl|AND (boolean)|AND}} GetKeyState({{Cl|ASC (function)|ASC}}("A")) < 0 {{Cl|THEN}} '<==== Shift+A
      y& = ShowWindow&(hwnd&, 1)
      {{Cl|PRINT}} "That is all. Hoped it worked."; x&; y&
      {{Cl|END}}
  {{Cl|END IF}}

  {{Cl|_LIMIT}} 30 'Don't be a hog
{{Cl|LOOP}}
{{CodeEnd}}
{{Small|Code courtesy of Dav}}
:'''Note:''' Virtual Hot keys can be used when a QB64 program is '''not in focus''' too! See '''[[Windows Libraries#Focus|Focus]]''' to bring a QB64 program into focus.
{{FixedStart}}'                                  '''Virtual KeyState Codes'''
'
' ''' Esc  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11 F12   Sys ScL Pause'''
'  27   112 113 114 115 116 117 118 119 120 121  122 123   44  145 19
' ''' `~  1!  2@  3#  4$  5%  6^  7&  8* 9(  0) -_  =+  BkS   Ins Hme PUp   NumL  /   *    -'''
'  192 49  50  51  52  53  54  55  56  57 48 189 187  8    45  36  33    144  111  106 109
' ''' Tab Q   W   E   R   T   Y   U   I   O   P  [{  ]}  \|   Del End PDn   7Hme 8/  9PU  +'''
'   9  81  87  69  82  84  89  85  73  79  80 219 221 120  46  35  34    103  104  105 107
' ''' CapL  A   S   D   F   G   H   J   K   L   ;:  '" Enter                4/-  5   6/- E'''
'   20   65  83  68  70  71  72  74  75  76 186 222  13                  100  101  102  '''n'''
' ''' Shift  Z   X   C   V   B   N   M   ,<  .>  /?    Shift               1End 2/  3PD  t'''
'  16/160 90  88  67  86  66  78  77 188  190 191   16/161      38       97   98   99   '''e'''
' ''' Ctrl   Win   Alt       Spacebar      Alt Win Menu Ctrl   -     -   0Ins     .Del  r'''
'  17/162 91  18/164        32        18/165 92  93 17/163  37  40  39   96        110  13
'
'      Num Lock On values shown. Off values same as functions and arrows, 5 = code 12.
'
'  '''Mouse click returns: LB = 1, RB = 2, MB = 4, etc. [http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx Special keys] may also work.'''
{{FixedEnd}}
{{Small|NOTE: The above commented table can be copied and pasted directly into the QB64 IDE}}


: '''Invisible key and mouse logger that does not require program focus. Press ESCape key to view the logged activity. '''
{{CodeStart}}
{{Cl|$CONSOLE}}
{{Cl|_DEST}} {{Cl|_CONSOLE}} ' for demonstration only
{{Cl|PRINT}} "The actual program is hiding. Type some stuff!"
{{Cl|PRINT}}
{{Cl|PRINT}} "Press ESC to quit logging keys and see results.":
{{Cl|_DEST}} 0
'====================== End Demo Console Code ===============================
{{Cl|DO...LOOP|DO}} : {{Cl|LOOP}} {{Cl|UNTIL}} {{Cl|_SCREENEXISTS}} 'to prevent unexpected freezing
{{Cl|_SCREENHIDE}} 'makes the program invisible to the user. Escape key displays log!

{{Cl|DECLARE LIBRARY}}  'function is already used by QB64 so "User32" is not required
  {{Cl|FUNCTION}} GetAsyncKeyState% ({{Cl|BYVAL}} vkey {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} theitem$(1000)

{{Cl|DO...LOOP|DO}}: {{Cl|_LIMIT}} 100
  {{Cl|FOR...NEXT|FOR}} thekey = {{Cl|&H}}30 {{Cl|TO}} {{Cl|&H}}5A
    {{Cl|IF...THEN|IF}} GetAsyncKeyState(thekey) {{Cl|THEN}}
      theitem$(a) = theitem$(a) + {{Cl|CHR$}}(thekey)
      {{Cl|DO...LOOP|DO}}
      {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(thekey) = 0
    {{Cl|END IF}}
  {{Cl|NEXT}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState(1) {{Cl|THEN}}
    a = a + 1
    theitem$(a) = "{MOUSE LEFT}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(1) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState(2) {{Cl|THEN}}
    a = a + 1
    theitem$(a) = "{MOUSE RIGHT}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(2) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState(4) {{Cl|THEN}}
    a = a + 1
    theitem$(a) = "{MOUSE MIDDLE}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(4) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState(8) {{Cl|THEN}}
    theitem$(a) = theitem$(a) + "{BS}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(8) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState(9) {{Cl|THEN}}
    theitem$(a) = theitem$(a) + "{TAB}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState(9) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState({{Cl|&H}}D) {{Cl|THEN}}
    a = a + 1
    theitem$(a) = "{ENTER}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState({{Cl|&H}}D) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState({{Cl|&H}}14) {{Cl|THEN}}
    theitem$(a) = theitem$(a) + "{CAPS {{Cl|LOCK}}}"
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState({{Cl|&H}}14) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState({{Cl|&H}}20) {{Cl|THEN}}
    theitem$(a) = theitem$(a) + " "
    {{Cl|DO...LOOP|DO}}
    {{Cl|LOOP}} {{Cl|UNTIL}} GetAsyncKeyState({{Cl|&H}}20) = 0
  {{Cl|END IF}}
  {{Cl|IF...THEN|IF}} GetAsyncKeyState({{Cl|&H}}1B) {{Cl|THEN}}
    theitem$(a) = theitem$(a) + "{ESC}"
    {{Cl|EXIT DO}} 'ESC key exits loop and prints logged key presses
  {{Cl|END IF}}
{{Cl|LOOP}}

{{Cl|_SCREENSHOW}} 'makes program visible with ESC key press
{{Cl|FOR...NEXT|FOR}} b = 0 {{Cl|TO}} a
  {{Cl|PRINT}} theitem$(b)
  {{Cl|IF...THEN|IF}} b {{Cl|MOD}} 20 = 19 {{Cl|THEN}} {{Cl|COLOR}} 12: {{Cl|PRINT}} "press any key": {{Cl|SLEEP}}: {{Cl|COLOR}} 7
{{Cl|NEXT}}
{{CodeEnd}}
{{Small|Code by Cyperium}}
: ''Note:'' The program will run invisibly without a program icon appearing in the task bar until the ESC key is pressed and the log will be displayed.

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Keyboard Lock Settings ==

Change Cap Lock, Scroll Lock and Number Lock settings and respective lights or onscreen indicators.
{{CodeStart}}
'public domain, 2012 april, michael calkins
{{Cl|CONST}} INPUT_KEYBOARD = 1
{{Cl|CONST}} KEYEVENTF_KEYDOWN = 0
{{Cl|CONST}} KEYEVENTF_KEYUP = {{Cl|&H}}2

{{Cl|CONST}} VK_CAPITAL = {{Cl|&H}}14
{{Cl|CONST}} VK_NUMLOCK = {{Cl|&H}}90
{{Cl|CONST}} VK_SCROLL = {{Cl|&H}}91

{{Cl|CONST}} scCapital = {{Cl|&H}}3A
{{Cl|CONST}} scNumlock = {{Cl|&H}}45
{{Cl|CONST}} scScroll = {{Cl|&H}}46

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
 {{Cl|FUNCTION}} GetLastError~& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
 {{Cl|FUNCTION}} SendInput~& ({{Cl|BYVAL}} nInputs~&, {{Cl|BYVAL}} pInputs%&, {{Cl|BYVAL}} cbSize&)
 {{Cl|FUNCTION}} GetMessageExtraInfo%& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|TYPE}} KeyInputStruc
 type {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 wVk {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
 wScan {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|INTEGER}}
 dwFlags {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 time {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 dwExtraInfo {{Cl|AS}} {{Cl|_OFFSET}}
 pad0 {{Cl|AS}} {{Cl|LONG}} 'to accomodate the size of a MOUSEINPUT
 pad1 {{Cl|AS}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DIM}} ki(0 {{Cl|TO}} 1) {{Cl|AS}} KeyInputStruc '2 index array will be zero initialized

ki(0).type = INPUT_KEYBOARD
ki(1).type = INPUT_KEYBOARD
ki(0).dwFlags = KEYEVENTF_KEYDOWN
ki(1).dwFlags = KEYEVENTF_KEYUP
ki(0).dwExtraInfo = GetMessageExtraInfo 'read function value
ki(1).dwExtraInfo = ki(0).dwExtraInfo   'assign same value

{{Cl|RANDOMIZE}} {{Cl|TIMER (function)|TIMER}}
{{Cl|DO...LOOP|DO}} {{Cl|UNTIL}} {{Cl|INKEY$}} = {{Cl|CHR$}}({{Cl|&H}}1B)
 {{Cl|_DELAY}} 2
 {{Cl|SELECT CASE}} {{Cl|INT}}({{Cl|RND}} * 3)
  {{Cl|CASE}} 0
   ki(0).wVk = VK_NUMLOCK
   ki(1).wVk = VK_NUMLOCK
   ki(0).wScan = scNumlock
   ki(1).wScan = scNumlock
   {{Cl|PRINT}} "Num lock..."
  {{Cl|CASE}} 1
   ki(0).wVk = VK_CAPITAL
   ki(1).wVk = VK_CAPITAL
   ki(0).wScan = scCapital
   ki(1).wScan = scCapital
   {{Cl|PRINT}} "Caps lock..."
  {{Cl|CASE}} 2
   ki(0).wVk = VK_SCROLL
   ki(1).wVk = VK_SCROLL
   ki(0).wScan = scScroll
   ki(1).wScan = scScroll
   {{Cl|PRINT}} "Scroll lock..."
 {{Cl|END SELECT}}
 l = SendInput(2, {{Cl|_OFFSET (function)|_OFFSET}}(ki(0)), {{Cl|LEN}}(ki(0))) '2 tells function to read two indices(0 and 1)
 {{Cl|IF...THEN|IF}} l <> 2 {{Cl|THEN}}
  {{Cl|PRINT}} l
  {{Cl|PRINT}} "0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END IF}}
{{Cl|LOOP}}
{{Cl|END}}
{{CodeEnd}}
{{Small|Code by Michael Calkins}}
: ''Note:'' In QB64 the number pad lock does not affect the [[INP]](&H60) release code returns of the [[extended keys]] like it did in QBasic.


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Message Box ==

{{CodeStart}}
'Message Box Constant values as defined by Microsoft (MBType)
{{Cl|CONST}} MB_OK& = 0                'OK button only
{{Cl|CONST}} MB_OKCANCEL& = 1          'OK & Cancel
{{Cl|CONST}} MB_ABORTRETRYIGNORE& = 2  'Abort, Retry & Ignore
{{Cl|CONST}} MB_YESNOCANCEL& = 3       'Yes, No & Cancel
{{Cl|CONST}} MB_YESNO& = 4             'Yes & No
{{Cl|CONST}} MB_RETRYCANCEL& = 5       'Retry & Cancel
{{Cl|CONST}} MB_CANCELTRYCONTINUE& = 6 'Cancel, Try Again & Continue
{{Cl|CONST}} MB_ICONSTOP& = 16         'Error stop sign icon
{{Cl|CONST}} MB_ICONQUESTION& = 32     'Question-mark icon
{{Cl|CONST}} MB_ICONEXCLAMATION& = 48  'Exclamation-point icon
{{Cl|CONST}} MB_ICONINFORMATION& = 64  'Letter i in a circle icon
{{Cl|CONST}} MB_DEFBUTTON1& = 0        '1st button default(left)
{{Cl|CONST}} MB_DEFBUTTON2& = 256      '2nd button default
{{Cl|CONST}} MB_DEFBUTTON3& = 512      '3rd button default(right)
{{Cl|CONST}} MB_APPLMODAL& = 0         'Message box applies to application only
{{Cl|CONST}} MB_SYSTEMMODAL& = 4096    'Message box on top of all other windows
{{Cl|CONST}} MB_SETFOCUS& = 65536      'Set message box as focus
{{Cl|CONST}} IDOK& = 1                 'OK button pressed
{{Cl|CONST}} IDCANCEL& = 2             'Cancel button pressed
{{Cl|CONST}} IDABORT& = 3              'Abort button pressed
{{Cl|CONST}} IDRETRY& = 4              'Retry button pressed
{{Cl|CONST}} IDIGNORE& = 5             'Ignore button pressed
{{Cl|CONST}} IDYES& = 6                'Yes button pressed
{{Cl|CONST}} IDNO& = 7                 'No button pressed
{{Cl|CONST}} IDTRYAGAIN& = 10          'Try again button pressed
{{Cl|CONST}} IDCONTINUE& = 1           'Continue button pressed
'----------------------------------------------------------------------------------------

{{Cl|DECLARE LIBRARY}}
{{Cl|FUNCTION}} MessageBox& ({{Cl|BYVAL}} Zer0 {{Cl|AS}} {{Cl|LONG}}, Message {{Cl|AS}} {{Cl|STRING}}, Title {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} MBType {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

DO
  msg& = 0: icon& = 0: DB& = 0
  {{Cl|INPUT}} "Enter Message Box type(0 to 6 other Quits): ", BOX&
  {{Cl|IF...THEN|IF}} BOX& < 0 {{Cl|OR (boolean)|OR}} BOX& > 6 {{Cl|THEN}} {{Cl|EXIT DO}}

  {{Cl|INPUT}} "Enter Icon&(0=none, 1=stop, 2=?, 3=!, 4=info): ", Icon&

  {{Cl|IF...THEN|IF}} BOX& {{Cl|THEN}} {{Cl|INPUT (file mode)|INPUT}} "Enter Default Button(1st, 2nd or 3rd): ", DB&
  {{Cl|IF...THEN|IF}} DB& {{Cl|THEN}} DB& = DB& - 1     'adjust value to 0, 1, or 2
  msg& = MsgBox&("Box Title", "Box text message", BOX&, Icon&, DB&, 4096) 'on top of all windows

  {{Cl|PRINT}} "Button ="; msg&
{{Cl|LOOP}}
{{Cl|END}}

{{Cl|FUNCTION}} MsgBox& (Title$, Message$, BoxType&, Icon&, DBtn&, Mode&)
{{Cl|SELECT CASE}} Icon&
  {{Cl|CASE}} 1: Icon& = MB_ICONSTOP&          'warning X-sign icon
  {{Cl|CASE}} 2: Icon& = MB_ICONQUESTION&      'question-mark icon
  {{Cl|CASE}} 3: Icon& = MB_ICONEXCLAMATION&   'exclamation-point icon
  {{Cl|CASE}} 4: Icon& = MB_ICONINFORMATION&   'lowercase letter i in circle
  {{Cl|CASE ELSE}}: Icon& = 0 'no icon
{{Cl|END SELECT}}
{{Cl|IF...THEN|IF}} BoxType& > 0 {{Cl|AND (boolean)|AND}} DBtn& > 0 {{Cl|THEN}} 'set default button as 2nd(256) or 3rd(512)
  {{Cl|SELECT CASE}} BoxType&
    {{Cl|CASE}} 2, 3, 6
     {{Cl|IF...THEN|IF}} DBtn& = 2 {{Cl|THEN}} Icon& = Icon& + MB_DEFBUTTON3& {{Cl|ELSE}} Icon& = Icon& + MB_DEFBUTTON2& '3 button
    {{Cl|CASE ELSE}}: Icon& = Icon& + MB_DEFBUTTON2& '2nd button default
  {{Cl|END SELECT}}
{{Cl|END IF}}
Focus& = MB_SetFocus&
MsgBox& = MessageBox&(0, Message$, Title$, BoxType& + Icon& + Mode& + Focus&) 'focus on button
{{Cl|END FUNCTION}}
{{CodeEnd}}
:'''Note:''' The demo above can show all of the possible message box options. The actual code necessary is quite simple.


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Mouse Area ==

: Program limits the mouse to a box portion of the Windows desktop using the Rectangle [[TYPE]] to define the mouse area.
{{CodeStart}}
{{Cl|TYPE}} Rectangle
  left {{Cl|AS}} {{Cl|LONG}}
  top {{Cl|AS}} {{Cl|LONG}}
  right {{Cl|AS}} {{Cl|LONG}}
  bottom {{Cl|AS}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}
{{Cl|DIM}} Rec {{Cl|AS}} Rectangle


{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "User32"
  {{Cl|FUNCTION}} ClipCursor%% (Rect {{Cl|AS}} Rectangle) 'sets mouse box work area on desktop
  {{Cl|SUB}} SetCursorPos ({{Cl|BYVAL}} x {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} y {{Cl|AS}} {{Cl|LONG}}) 'move cursor position
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|SCREEN}} {{Cl|_NEWIMAGE}}(320, 200, 32)
SetCursorPos 40, 36  'move cursor to left side of desktop

{{Cl|PRINT}} "Press a key and the mouse is boxed in!"
K$ = {{Cl|INPUT$}}(1)

Rec.left = 600
Rec.top = 400
Rec.bottom = 700
Rec.right = 800
work%% = ClipCursor(Rec)

{{Cl|CLS}}
{{Cl|PRINT}} work%%
{{Cl|PRINT}} "Click the mouse and window to quit!"
DO
  m = {{Cl|_MOUSEINPUT}}

{{Cl|LOOP}} {{Cl|UNTIL}} {{Cl|_MOUSEBUTTON}}(2) {{Cl|OR (boolean)|OR}} {{Cl|_MOUSEBUTTON}}(1)
SetCursorPos 40, 36 'attempts to move mouse to left

{{Cl|SYSTEM}}
{{CodeEnd}}
: ''Note:'' The left and top positions must be less than the bottom and right pixel position values. Click mouse to exit box area. Click program window to quit.


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Open another Program ==

{{CodeStart}}
'Uses Kernel32 WinAPI to execute a program in a QB64 program.  Coded by Dav

{{Cl|DECLARE LIBRARY}}
  Function WinExec (lpCmdLine AS {{Cl|STRING}}, {{Cl|BYVAL}} nCmdShow AS {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

Winmode% = 1

'0 = Hides the window and activates another window.
'1 = Activates and displays a normal sized window.
'2 = Activates the window and minimized to taskbar.
'3 = Activates the window and displays it as a maximized window.

'NOTE: If you do 0 (hide), you'll have to Kill the process using your TaskManager!!!

'=== Open notepad and load samples.txt in the QB64 directory

Filename$ = "notepad.exe samples.txt" + {{Cl|CHR$}}(0)

'NOTE: EXE filename must be a NULL terminates..{{Cl|CHR$}}(0)...

Result = WinExec(Filename$, Winmode%)

'=== Show results ...

{{Cl|SELECT CASE}} Result
   {{Cl|CASE}} 0: {{Cl|PRINT}} "System out of memory or resources."
   {{Cl|CASE}} 2: {{Cl|PRINT}} "The specified file was not found."
   {{Cl|CASE}} 3: {{Cl|PRINT}} "The specified path was not found."
   {{Cl|CASE}} 11: {{Cl|PRINT}} "The file is invalid (non-Win32 .EXE or error in .EXE image)."
   {{Cl|CASE|CASE IS}} > 31: {{Cl|PRINT}} "Program opened normally."
   {{Cl|CASE ELSE}}: {{Cl|PRINT}} "Unknown error: "; Result
{{Cl|END SELECT}}
{{Cl|END}}
{{CodeEnd}}
{{Small|Code by Dav}}
:''Note:'' The Library file can only run valid Windows executable programs. Not DOS console EXE programs!


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Play WAV Sounds ==

{{CodeStart}}
{{Cl|CONST}} SND_SYNC = 0 'Windows controlled
{{Cl|CONST}} SND_ASYNC = 1 'user controlled
{{Cl|CONST}} SND_NODEFAULT = 2 'only plays sound file requested
{{Cl|CONST}} SND_LOOP = 8 'loops the sound. Use ASYNC also to stop later
{{Cl|CONST}} SND_NOSTOP = {{Cl|&H}}10 'does not allow a sound to be stopped
{{Cl|CONST}} SND_NOWAIT = {{Cl|&H}}2000 'will not play sound if driver is busy
{{Cl|CONST}} SND_PURGE = {{Cl|&H}}40 'stop any sound playing

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "winmm"
  {{Cl|FUNCTION}} PlaySound% {{Cl|ALIAS}} PlaySoundA (lpszName {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} hModule {{Cl|AS}} {{Cl|INTEGER}}, {{Cl|BYVAL}} dwFlags {{Cl|AS}} {{Cl|INTEGER}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|LINE INPUT}} "Enter WAV sound file name: ", FileName$
{{Cl|PRINT}} "Play asynchronously?(Y/N) ";
K$ = {{Cl|UCASE$}}({{Cl|INPUT$}}(1))
{{Cl|PRINT}} K$
{{Cl|IF...THEN|IF}} K$ = "Y" {{Cl|THEN}} Synch = SND_ASYNC {{Cl|ELSE}} Synch = SND_SYNC

retval% = PlaySound(FileName$, 0, Synch)
{{CodeEnd}}
{{Small|Code by Ted Weissgerber}}
: ''Note:'' ASYNC allows the program to stop the sound by sending a null file name. Flag constants can be added so loop and ASYNC would total 9.


<center>'''[http://msdn.microsoft.com/en-us/library/ms712636 WINMM.DLL Functions]'''</center>


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Run One Instance ==

Program catches another instance of the program descriptor label running and closes it
{{CodeStart}}
{{Cl|CONST}} ERROR_ALREADY_EXISTS = {{Cl|&H}}B7

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
 {{Cl|FUNCTION}} CreateMutexA%& ({{Cl|BYVAL}} lpMutexAttributes%&, {{Cl|BYVAL}} bInitialOwner&, {{Cl|BYVAL}} lpName%&)
 {{Cl|FUNCTION}} GetLastError~& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} t {{Cl|AS}} {{Cl|STRING}}

t = "Global\Some name unique to your program" + {{Cl|CHR$}}(0)
' see: http://msdn.microsoft.com/en-us/library/ms682411%28v=vs.85%29

{{Cl|IF...THEN|IF}} 0 = CreateMutexA(0, 0, {{Cl|_OFFSET (function)|_OFFSET}}(t)) {{Cl|THEN}}
 {{Cl|PRINT}} "CreateMutexA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END}}
{{Cl|END IF}}
{{Cl|IF...THEN|IF}} ERROR_ALREADY_EXISTS = GetLastError {{Cl|THEN}}
 {{Cl|PRINT}} "Sorry. There can be only one."
 {{Cl|SLEEP}} 2
 {{Cl|SYSTEM}}
{{Cl|END IF}}

{{Cl|PRINT}} "But the most wonderful thing about tiggers is I'm the only one."
{{Cl|DO...LOOP|DO}} {{Cl|UNTIL}} {{Cl|INKEY$}} = {{Cl|CHR$}}({{Cl|&H}}1B)
{{Cl|LOOP}}
{{Cl|SYSTEM}}
{{CodeEnd}}
{{Small|Code courtesy of Michael Calkins}}
:''Explanation:'' The same identification string is used in both instances of the running program. Compile example, run the EXE and try to compile and run another instance. 'Sorry. There can be only one.' will be printed to the screen and then it will close.


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Send Keys ==

{{CodeStart}}
'============
'SENDKEYS.BAS
'============
'A kind of SENDKEYS clone for QB64. Sends keystrokes to active application.
'Coded for QB64 by Dav, JAN/2013


{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
    {{Cl|SUB}} SENDKEYS {{Cl|ALIAS}} keybd_event ({{Cl|BYVAL}} bVk {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} bScan {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} dwFlags {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} dwExtraInfo {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|CONST}} KEYEVENTF_KEYUP = {{Cl|&H}}2
{{Cl|CONST}} VK_SNAPSHOT = {{Cl|&H}}2C 'PrtScn key
{{Cl|CONST}} VK_MENU = {{Cl|&H}}12 'Alt key
{{Cl|CONST}} VK_SHIFT = {{Cl|&H}}10 'Shift key
{{Cl|CONST}} VK_LWIN = {{Cl|&H}}5B

{{Cl|PRINT}} ""
{{Cl|PRINT}} "SENDKEYS clone example.  Press ENTER to begin..."
{{Cl|PRINT}}

{{Cl|WHILE}} {{Cl|INKEY$}} <> {{Cl|CHR$}}(13): {{Cl|WEND}}

'=== Capture Active window to Clipoard as image (Like Alt+PrtSc)
SENDKEYS VK_MENU, 0, 0, 0
SENDKEYS VK_SNAPSHOT, 0, 0, 0
SENDKEYS VK_SNAPSHOT, 0, KEYEVENTF_KEYUP, 0
SENDKEYS VK_MENU, 0, KEYEVENTF_KEYUP, 0

{{Cl|PRINT}} "SENDKEYS just sent a Alt+PrtSc keyboard press."
{{Cl|PRINT}} "A screen-cap of this EXE {{Cl|WINDOW}} was just sent to your clipboard."
{{Cl|PRINT}} "Go ahead, check it now, then come back here and press ENTER..."

{{Cl|WHILE}} {{Cl|INKEY$}} <> {{Cl|CHR$}}(13): {{Cl|WEND}}

'=== Capture Desktop screen to Clipoard as image (Like Shift+PrtSc)
SENDKEYS VK_SHIFT, 0, 0, 0
SENDKEYS VK_SNAPSHOT, 0, 0, 0
SENDKEYS VK_SNAPSHOT, 0, KEYEVENTF_KEYUP, 0
SENDKEYS VK_SHIFT, 0, KEYEVENTF_KEYUP, 0

{{Cl|PRINT}}
{{Cl|PRINT}} "Now SENDKEYS just sent a Shift+PrtSc keyboard press."
{{Cl|PRINT}} "A screen-cap of your DESKTOP was just sent to your clipboard."
{{Cl|PRINT}} "Go ahead, check it now, then come back here and press ENTER..."
{{Cl|PRINT}}

{{Cl|WHILE}} {{Cl|INKEY$}} <> {{Cl|CHR$}}(13): {{Cl|WEND}}

{{Cl|PRINT}} "Now 'Notepad.exe' will open and SENDKEYS will send text to it."
{{Cl|PRINT}} "Press ENTER to do that now, then close notepad, come back here,"
{{Cl|PRINT}} "and press ENTER to continue..."

{{Cl|WHILE}} {{Cl|INKEY$}} <> {{Cl|CHR$}}(13): {{Cl|WEND}}

{{Cl|SHELL}} {{Cl|_DONTWAIT}} "notepad.exe"

{{Cl|SLEEP}} 1 'give time to make notepad the active window...

'=== Say Hi...
SENDKEYS {{Cl|&H}}48, 0, 0, 0: SENDKEYS {{Cl|&H}}48, 0, KEYEVENTF_KEYUP, 0 'H
SENDKEYS {{Cl|&H}}49, 0, 0, 0: SENDKEYS {{Cl|&H}}49, 0, KEYEVENTF_KEYUP, 0 'i

{{Cl|PRINT}}
{{Cl|PRINT}} "Now press ENTER for SENDKEYS to Minimize all your windows..."
{{Cl|PRINT}}

{{Cl|WHILE}} {{Cl|INKEY$}} <> {{Cl|CHR$}}(13): {{Cl|WEND}}

'=== Minimize windows shortcut
SENDKEYS VK_LWIN, 0, 0, 0
SENDKEYS {{Cl|&H}}4D, 0, 0, 0
SENDKEYS VK_LWIN, 0, KEYEVENTF_KEYUP, 0

{{Cl|PRINT}} "That's all. have a nice day."

{{Cl|END}}
{{CodeEnd}}
{{Small|Code courtesy of Dav}}

{{FixedStart}}'                                  '''Virtual KeyState Codes'''
'
' ''' Esc  F1  F2  F3  F4  F5  F6  F7  F8  F9  F10  F11 F12   Sys ScL Pause'''
'  27   112 113 114 115 116 117 118 119 120 121  122 123   44  145 19
' ''' `~  1!  2@  3#  4$  5%  6^  7&  8* 9(  0) -_  =+  BkS   Ins Hme PUp   NumL  /   *    -'''
'  192 49  50  51  52  53  54  55  56  57 48 189 187  8    45  36  33    144  111  106 109
' ''' Tab Q   W   E   R   T   Y   U   I   O   P  [{  ]}  \|   Del End PDn   7Hme 8/  9PU  +'''
'   9  81  87  69  82  84  89  85  73  79  80 219 221 120  46  35  34    103  104  105 107
' ''' CapL  A   S   D   F   G   H   J   K   L   ;:  '" Enter                4/-  5   6/- E'''
'   20   65  83  68  70  71  72  74  75  76 186 222  13                  100  101  102  '''n'''
' ''' Shift  Z   X   C   V   B   N   M   ,<  .>  /?    Shift               1End 2/  3PD  t'''
'  16/160 90  88  67  86  66  78  77 188  190 191   16/161      38       97   98   99   '''e'''
' ''' Ctrl   Win   Alt       Spacebar      Alt Win Menu Ctrl   -     -   0Ins     .Del  r'''
'  17/162 91  18/164        32        18/165 92  93 17/163  37  40  39   96        110  13
'
'      Num Lock On values shown. Off values same as functions and arrows, 5 = code 12.
'
'  '''Mouse click returns: LB = 1, RB = 2, MB = 4, etc. [http://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx Special keys] may also work.'''
{{FixedEnd}}
{{Small|NOTE: The above commented table can be copied and pasted directly into the QB64 IDE}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== System Metrics ==

: Returns the dimensions of the current user's desktop. Can be used to get various Windows settings.
{{CodeStart}}
{{Cl|CONST}} SM_CXSCREEN = 0 'Width of user desktop
{{Cl|CONST}} SM_CYSCREEN = 1 'Height of user desktop
{{Cl|CONST}} SM_CXFULLSCREEN = 16 ' Width of window client area
{{Cl|CONST}} SM_CYFULLSCREEN = 17 ' Height of window client area
{{Cl|CONST}} SM_CYMENU = 15 ' Height of menu
{{Cl|CONST}} SM_CYCAPTION = 4 ' Height of caption or title
{{Cl|CONST}} SM_CXFRAME = 32 ' Width of window frame
{{Cl|CONST}} SM_CYFRAME = 33 ' Height of window frame
{{Cl|CONST}} SM_CXHSCROLL = 21 ' Width of arrow bitmap on horizontal scroll bar
{{Cl|CONST}} SM_CYHSCROLL = 3 ' Height of arrow bitmap on horizontal scroll bar
{{Cl|CONST}} SM_CXVSCROLL = 2 ' Width of arrow bitmap on vertical scroll bar
{{Cl|CONST}} SM_CYVSCROLL = 20 ' Height of arrow bitmap on vertical scroll bar
{{Cl|CONST}} SM_CXSIZE = 30 ' Width of bitmaps in title bar
{{Cl|CONST}} SM_CYSIZE = 31 ' Height of bitmaps in title bar
{{Cl|CONST}} SM_CXCURSOR = 13 ' Width of cursor
{{Cl|CONST}} SM_CYCURSOR = 14 ' Height of cursor
{{Cl|CONST}} SM_CXBORDER = 5 ' Width of window frame that cannot be sized
{{Cl|CONST}} SM_CYBORDER = 6 ' Height of window frame that cannot be sized
{{Cl|CONST}} SM_CXDOUBLECLICK = 36 ' Width of rectangle around the location of the first click.
{{Cl|CONST}} SM_CYDOUBLECLICK = 37 ' Height of rectangle around the location of the first click.
{{Cl|CONST}} SM_CXDLGFRAME = 7 ' Width of dialog frame window
{{Cl|CONST}} SM_CYDLGFRAME = 8 ' Height of dialog frame window
{{Cl|CONST}} SM_CXICON = 11 ' Width of icon
{{Cl|CONST}} SM_CYICON = 12 ' Height of icon
{{Cl|CONST}} SM_CXICONSPACING = 38 ' Width of rectangles the system uses to position tiled icons
{{Cl|CONST}} SM_CYICONSPACING = 39 ' Height of rectangles the system uses to position tiled icons
{{Cl|CONST}} SM_CXMIN = 28 ' Minimum width of window
{{Cl|CONST}} SM_CYMIN = 29 ' Minimum height of window
{{Cl|CONST}} SM_CXMINTRACK = 34 ' Minimum tracking width of window
{{Cl|CONST}} SM_CYMINTRACK = 35 ' Minimum tracking height of window
{{Cl|CONST}} SM_CXHTHUMB = 10 ' Width of scroll box (thumb) on horizontal scroll bar
{{Cl|CONST}} SM_CYVTHUMB = 9 ' Width of scroll box (thumb) on vertical scroll bar
{{Cl|CONST}} SM_DBCSENABLED = 42 ' Returns a non-zero if the current Windows version uses double-byte characters, otherwise zero
{{Cl|CONST}} SM_DEBUG = 22 ' Returns non-zero if the Windows version is a debugging version
{{Cl|CONST}} SM_MENUDROPALIGNMENT = 40 'Alignment of pop-up menus.
{{Cl|CONST}} SM_MOUSEPRESENT = 19 ' Non-zero if mouse hardware is installed
{{Cl|CONST}} SM_PENWINDOWS = 41 ' Handle of Pen Windows dynamic link library if Pen Windows is installed
{{Cl|CONST}} SM_SWAPBUTTON = 23 ' Non-zero if the left and right mouse buttons are swapped

{{Cl|DECLARE LIBRARY}}
    {{Cl|FUNCTION}} GetSystemMetrics& ({{Cl|BYVAL}} n {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|PRINT}} trimstr$(GetSystemMetrics(SM_CXSCREEN)); "x"; trimstr$(GetSystemMetrics(SM_CYSCREEN))

s& = {{Cl|_SCREENIMAGE}}
{{Cl|PRINT}} {{Cl|_WIDTH (function)|_WIDTH}}(s&); "X"; {{Cl|_HEIGHT}}(s&)

{{Cl|END}} 3

{{Cl|FUNCTION}} trimstr$ (whatever)
trimstr = {{Cl|LTRIM$}}({{Cl|RTRIM$}}({{Cl|STR$}}(whatever)))
{{Cl|END FUNCTION}}
{{CodeEnd}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Top Most Window ==

: This Windows only procedure will make the program window always stay on top of other windows, but not always in focus. (See [[Windows Libraries#Focus|Windows Focus]])
{{CodeStart}}
'public domain

{{Cl|CONST}} SWP_NOSIZE = {{Cl|&H}}0001      'ignores cx and cy size parameters
{{Cl|CONST}} SWP_NOMOVE = {{Cl|&H}}0002      'ignores x and y position parameters
{{Cl|CONST}} SWP_NOZORDER = {{Cl|&H}}0004    'keeps z order and ignores hWndInsertAfter parameter
{{Cl|CONST}} SWP_NOREDRAW = {{Cl|&H}}0008    'does not redraw window changes
{{Cl|CONST}} SWP_NOACTIVATE = {{Cl|&H}}0010  'does not activate window
{{Cl|CONST}} SWP_FRAMECHANGED = {{Cl|&H}}0020
{{Cl|CONST}} SWP_SHOWWINDOW = {{Cl|&H}}0040
{{Cl|CONST}} SWP_HIDEWINDOW = {{Cl|&H}}0080
{{Cl|CONST}} SWP_NOCOPYBITS = {{Cl|&H}}0100
{{Cl|CONST}} SWP_NOOWNERZORDER = {{Cl|&H}}0200
{{Cl|CONST}} SWP_NOSENDCHANGING = {{Cl|&H}}0400
{{Cl|CONST}} SWP_DRAWFRAME = SWP_FRAMECHANGED
{{Cl|CONST}} SWP_NOREPOSITION = SWP_NOOWNERZORDER
{{Cl|CONST}} SWP_DEFERERASE = {{Cl|&H}}2000
{{Cl|CONST}} SWP_ASYNCWINDOWPOS = {{Cl|&H}}4000
{{Cl|CONST}} HWND_TOP = 0        'window at top of z order no focus
{{Cl|CONST}} HWND_BOTTOM = 1     'window at bottom of z order no focus
{{Cl|CONST}} HWND_TOPMOST = -1   'window above all others no focus unless active
{{Cl|CONST}} HWND_NOTOPMOST = -2 'window below active no focus

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
 {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} lpClassName%&, {{Cl|BYVAL}} lpWindowName%&)
 {{Cl|FUNCTION}} SetWindowPos& ({{Cl|BYVAL}} hWnd%&, {{Cl|BYVAL}} hWndInsertAfter%&, {{Cl|BYVAL}} X&, {{Cl|BYVAL}} Y&, {{Cl|BYVAL}} cx&, {{Cl|BYVAL}} cy&, {{Cl|BYVAL}} uFlags~&)
 {{Cl|FUNCTION}} GetForegroundWindow%&
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
 {{Cl|FUNCTION}} GetLastError~& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} t {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} hWnd {{Cl|AS}} {{Cl|_OFFSET}}

{{Cl|RANDOMIZE}} {{Cl|TIMER (function)|TIMER}}
t = {{Cl|HEX$}}({{Cl|RND}} * {{Cl|&H}}1000000) 'random title for FindWindowA
{{Cl|_TITLE}} t
t = t + {{Cl|CHR$}}(0)
hWnd = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, {{Cl|_OFFSET (function)|_OFFSET}}(t))
{{Cl|_TITLE}} "This Window will always be on Top" 'any title

{{Cl|_DELAY}} 4 'delay allows user to click focus on other windows

'set as topmost window and move without sizing or activation
{{Cl|IF...THEN|IF}} 0 = SetWindowPos(hWnd, HWND_TOPMOST, 200, 200, 0, 0, SWP_NOSIZE {{Cl|OR (boolean)|OR}} SWP_NOACTIVATE) {{Cl|THEN}}
 {{Cl|PRINT}} "SetWindowPos failed. 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
{{Cl|END IF}}

x%& = GetForegroundWindow%& 'find currently focused process handle

{{Cl|PRINT}} "Program handle:"; hWnd; "Focus handle:"; x%&
{{Cl|IF...THEN|IF}} hWnd <> x%& {{Cl|THEN}} {{Cl|_SCREENCLICK}} 240, 240 'add 40 to x and y to focus on positioned window

{{Cl|END}}
{{CodeEnd}}
{{Small|Adapted from code by Michael Calkins}}
: ''Explanation:'' When other windows are clicked on, this program window will stay on top. Click it to return focus.
:: ''SetWindowPos'' can also move the window's TLC corner position and re-size the window when not flagged.
:: When the window is moved to a position, [[_SCREENCLICK]] can be used to focus on the program window.
<center>'''''[[Windows Libraries#Focus|SetForegroundWindow]]'' will not work with the ''SetWindowPos''!'''</center>


<center>[http://msdn.microsoft.com/en-us/library/ms633545%28v=vs.85%29 http://msdn.microsoft.com/en-us/library/ms633545%28v=vs.85%29]</center>

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Video File Player ==

Video player for MPG or AVI video files:
{{CodeStart}}
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "WINMM"
    {{Cl|FUNCTION}} mciSendStringA% (lpstrCommand {{Cl|AS}} {{Cl|STRING}}, lpstrReturnString {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} uReturnLength {{Cl|AS}} {{Cl|INTEGER}}, {{Cl|BYVAL}} hwndCallback {{Cl|AS}} {{Cl|INTEGER}})
    ' mciSendStringA function plays media files and returns the following:
    ' 0 = command sucessful
    ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    ' lpstrCommand is the MCI command string (and optional flags) to send.
    ' lpstrReturnString is a string that holds any return information.
    ' uReturnLength is the length of the lpstrReturnString string passed.
    ' {{Cl|NOT}}E: If lpstrCommand given doesn't retun a value then lpstrReturnString
    '       can be empty and uReturnLength can be set to 0.
    ' hwndCallback contains a callback window handle (only if the Notify flag used in lpstrCommand)
    '====================================================================
    {{Cl|FUNCTION}} mciGetErrorStringA% ({{Cl|BYVAL}} dwError {{Cl|AS}} {{Cl|INTEGER}}, lpstrBuffer {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} uLength {{Cl|AS}} {{Cl|INTEGER}})
    ' mciGetErrorStringA returns error info if the mciSendStringA failed.
    ' dwError is the return value from the mciSendString function.
    ' lpstrBuffer string holds the error information returned by the function.
    ' uLength is the length of the lpstrBuffer string buffer.
    '====================================================================
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE CUSTOMTYPE LIBRARY}}
    {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$)
{{Cl|DECLARE LIBRARY|END DECLARE}}


handle& = {{Cl|_NEWIMAGE}}(800, 600, 256)
{{Cl|SCREEN}} handle&


{{Cl|_TITLE}} "QB64 Video"
hwnd& = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "QB64 Video" + {{Cl|CHR$}}(0))

ReturnString$ = {{Cl|SPACE$}}(255)
ErrorString$ = {{Cl|SPACE$}}(255)
filename$ = "c:\DavPiano.mpg" '<========== video file to play

a% = mciSendStringA%("open " + filename$ + " style popup", ReturnString$, {{Cl|LEN}}(ReturnString$), 0)

{{Cl|IF...THEN|IF}} a% {{Cl|THEN}}
    x% = mciGetErrorStringA%(a%, ErrorString$, {{Cl|LEN}}(ErrorString$))
    {{Cl|PRINT}} ErrorString$
    {{Cl|END}}
{{Cl|ELSE}}
    a2% = mciSendStringA%("window " + filename$ + " handle " + {{Cl|STR$}}(hwnd&), ReturnString$, {{Cl|LEN}}(ReturnString$), 0)
    b% = mciSendStringA%("play " + filename$, "", 0, 0)
    {{Cl|_SCREENMOVE}} {{Cl|_SCREENMOVE|_MIDDLE}}
    '=== Play video...
    {{Cl|DO...LOOP|DO}}: {{Cl|_LIMIT}} 30: {{Cl|LOOP}} {{Cl|UNTIL}} {{Cl|INKEY$}} <> ""

    x% = mciSendStringA%("stop " + filename$, "", 0, 0)
    x% = mciSendStringA%("close " + filename$, "", 0, 0)
{{Cl|END IF}}
{{CodeEnd}}
{{Small|Code courtesy of Dav}}


== Web Page Download ==

: Downloads the contents of a web page as an HTML or text file. Text can be edited for page information.
{{CodeStart}}
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "urlmon"
  {{Cl|FUNCTION}} URLDownloadToFileA% ({{Cl|BYVAL}} pCaller {{Cl|AS}} {{Cl|LONG}}, szURL {{Cl|AS}} {{Cl|STRING}}, szFileName {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} dwReserved {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} lpfnCB {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

'=== URL to grab (page or a file)
URL$ = <nowiki>"http://www.qbasicnews.com/dav/"</nowiki>
'=== File to save URL as
URLfile$ = "DavsIndex.html"

'=== Download it.  Returns 0 if succeeded
a% = URLDownloadToFileA%(0, URL$, URLfile$, 0, 0)

{{Cl|PRINT}} "Grabbing : "; URL$: {{Cl|PRINT}} "Saving as: "; URLfile$
{{Cl|PRINT}} "Sleeping 7 secs to do the deed..."
{{Cl|SLEEP}} 7
{{Cl|PRINT}} a%
{{CodeEnd}}
{{Small|Code courtesy of Dav}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows API ==


: Program finds the window handle by the [[_TITLE|title]] and then does various things with the window using that handle [[_OFFSET]] value.
{{CodeStart}}
{{Cl|CONST}} HWND_BOTTOM = 1     'places the window at the bottom of the Z order
{{Cl|CONST}} HWND_TOP = 0        'places the window at the top of the Z order
{{Cl|CONST}} HWND_TOPMOST = -1   'places the window above all non-topmost windows
{{Cl|CONST}} HWND_NOTOPMOST = -2 'places the window behind all topmost windows

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} class {{Cl|AS}} {{Cl|_OFFSET}}, Title$)
  {{Cl|FUNCTION}} CloseWindow& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}})
  {{Cl|FUNCTION}} OpenIcon& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}})
  {{Cl|FUNCTION}} SetWindowTextA& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}}, NewTitle$)
  {{Cl|FUNCTION}} GetWindowThreadProcessId& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} null {{Cl|AS}} {{Cl|LONG}})
  {{Cl|FUNCTION}} SetWindowPos& ({{Cl|BYVAL}} hwnd%&, {{Cl|BYVAL}} Zorder&, {{Cl|BYVAL}} X&, {{Cl|BYVAL}} Y&, {{Cl|BYVAL}} cx&, {{Cl|BYVAL}} cy&, {{Cl|BYVAL}} flag&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|_TITLE}} "Windows Test"

'// Get the window handle (as a long)
hwnd%& = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, "Windows Test" + {{Cl|CHR$}}(0))
{{Cl|PRINT}} "Handle:"; hwnd%&
{{Cl|_DELAY}} 3

'// Minimize the window - places program on the task bar
ret& = CloseWindow(hwnd%&)
{{Cl|PRINT}} "Minimize"; ret&
{{Cl|_DELAY}} 3 '// wait a few seconds

'// Restore the window
ret& = OpenIcon(hwnd%&)
{{Cl|PRINT}} "Restore"; ret&
{{Cl|_DELAY}} 3

'// Sets window priority as TOPMOST and moves the window position column 200, row 0
ret& = SetWindowPos(hwnd%&, HWND_TOPMOST, 200, 0, 0, 0, 0)
{{Cl|PRINT}} "Position"; ret&
{{Cl|_DELAY}} 3

'// Change the title of window header to new name
ret& = SetWindowTextA(hwnd%&, "Windows API Test")
{{Cl|PRINT}} "Title"; ret&

'// Get and display the process id for the window using new title name
PID& = GetWindowThreadProcessId(hwnd%&, 0)
{{Cl|PRINT}} "Process ID:"; PID&

{{Cl|END}}
{{CodeEnd}}
{{Small|Adapted from header code by Cyperium and Unseenmachine}}
: ''Note:'' ''SetWindowPos&'' function sets the pixel location on the desktop and the window dimensions. It can also set the window's Z order priority.
<center>'''The window handle value and process ID never change! Even when the title is changed.'''</center>

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Window Focus ==

Windows API routine can tell a program when it has lost focus by the user clicking on a different program window or the desktop.
{{CodeStart}}
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
    {{Cl|FUNCTION}} GetForegroundWindow%& ()
    {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} lpClassName%&, {{Cl|BYVAL}} lpWindowName%&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} title {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} hWnd {{Cl|AS}} {{Cl|_OFFSET}}

title = "Whatever you actually want the title to be"
{{Cl|_TITLE}} title
title = title + {{Cl|CHR$}}(0) 'always add character zero to FindWindowA string parameter
hWnd = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, {{Cl|_OFFSET (function)|_OFFSET}}(title))

{{Cl|DO...LOOP|DO}} {{Cl|UNTIL}} {{Cl|LEN}}({{Cl|INKEY$}})
    {{Cl|IF...THEN|IF}} hWnd = GetForegroundWindow {{Cl|THEN}} {{Cl|PRINT}} "foreground" {{Cl|ELSE}} {{Cl|PRINT}} "not foreground"
    {{Cl|SLEEP}} 1
{{Cl|LOOP}}
{{Cl|END}}
{{CodeEnd}}
{{Small|Adapted from code by Michael Calkins}}
: ''Note:'' [[CHR$]](0) could actually be added to the original title string and it wouldn't hurt anything. Compared values are [[_OFFSET]]s.

<center>'''See [[Windows Libraries#Focus|SetForegroundWindow to set Focus]] on program.'''</center>

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows Menu ==

<center>'''Creates a menu bar in the program window with a name that can be clicked on to execute a procedure.'''</center>
{{CodeStart}}
{{Cl|DEFLNG}} A-Z

{{Cl|CONST}} MIIM_STATE = {{Cl|&H}}1
{{Cl|CONST}} MIIM_ID = {{Cl|&H}}2
{{Cl|CONST}} MIIM_TYPE = {{Cl|&H}}10
{{Cl|CONST}} MFT_SEPARATOR = {{Cl|&H}}800
{{Cl|CONST}} MFT_STRING = {{Cl|&H}}0
{{Cl|CONST}} MFS_ENABLED = {{Cl|&H}}0
{{Cl|CONST}} MFS_CHECKED = {{Cl|&H}}8

{{Cl|CONST}} HWND_TOPMOST = -1
{{Cl|CONST}} HWND_NOTOPMOST = -2
{{Cl|CONST}} SWP_NOMOVE = {{Cl|&H}}2
{{Cl|CONST}} SWP_NOSIZE = {{Cl|&H}}1
'-----------------------------------------------------------------------------------

{{Cl|TYPE}} MENUITEMINFO
    cbSize {{Cl|AS}} {{Cl|LONG}}
    fMask {{Cl|AS}} {{Cl|LONG}}
    fType {{Cl|AS}} {{Cl|LONG}}
    fState {{Cl|AS}} {{Cl|LONG}}
    wID {{Cl|AS}} {{Cl|LONG}}
    hSubMenu {{Cl|AS}} {{Cl|LONG}}
    hbmpChecked {{Cl|AS}} {{Cl|LONG}}
    hbmpUnchecked {{Cl|AS}} {{Cl|LONG}}
    dwItemData {{Cl|AS}} {{Cl|_OFFSET}}
    dwTypeData {{Cl|AS}} {{Cl|_OFFSET}}
    cch {{Cl|AS}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DECLARE LIBRARY}}
    {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) ' To get hWnd handle
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
  {{Cl|FUNCTION}} CreateMenu& ()
  {{Cl|FUNCTION}} DrawMenuBar ({{Cl|BYVAL}} hWnd&)
  {{Cl|FUNCTION}} SetMenu& ({{Cl|BYVAL}} hWnd&, {{Cl|BYVAL}} hMenu&)
  {{Cl|FUNCTION}} InsertMenuItemA& ({{Cl|BYVAL}} hMenu&, {{Cl|BYVAL}} uItem&, {{Cl|BYVAL}} fByPosition&, {{Cl|BYVAL}} lpmii {{Cl|AS}} {{Cl|_OFFSET}})
  {{Cl|FUNCTION}} GetMenuItemCount& ({{Cl|BYVAL}} hMenu&)
  {{Cl|FUNCTION}} GetMenuItemInfoA& ({{Cl|BYVAL}} hMenu&, {{Cl|BYVAL}} uItem&, {{Cl|BYVAL}} fByPosition&, {{Cl|BYVAL}} lpmii {{Cl|AS}} {{Cl|_OFFSET}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} hWnd {{Cl|AS}} {{Cl|LONG}}
{{Cl|DIM}} hMenu {{Cl|AS}} {{Cl|LONG}}
{{Cl|DIM}} MenuItem {{Cl|AS}} MENUITEMINFO, BlankMenuItem {{Cl|AS}} MENUITEMINFO
{{Cl|DIM}} TypeData {{Cl|AS}} {{Cl|STRING}} * 1000

{{Cl|_TITLE}} "Menu bar API demo"
hWnd = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "Menu bar API demo" + {{Cl|CHR$}}(0))

hMenu = CreateMenu: BlankMenuItem.cbSize = {{Cl|LEN}}(BlankMenuItem)

{{Cl|COLOR}} 7, 1: {{Cl|CLS}}

'Add a separator bar
count = GetMenuItemCount(hMenu): {{Cl|PRINT}} "MenuItemCount:"; count
MenuItem = BlankMenuItem
MenuItem.fMask = MIIM_ID {{Cl|OR (boolean)|OR}} MIIM_{{Cl|TYPE}}
MenuItem.fType = MFT_SEPARATOR
MenuItem.wID = count
{{Cl|IF...THEN|IF}} InsertMenuItemA(hMenu, count, 1, {{Cl|_OFFSET (function)|_OFFSET}}(MenuItem)) {{Cl|THEN}} {{Cl|PRINT}} "Successfully added menu item!" {{Cl|ELSE}} {{Cl|PRINT}} "Failed to add menu item!": {{Cl|END}}

'Add a button
MenuItem = BlankMenuItem
count = GetMenuItemCount(hMenu): {{Cl|PRINT}} "MenuItemCount:"; count
MenuItem.fMask = MIIM_STATE {{Cl|OR (boolean)|OR}} MIIM_ID {{Cl|OR (boolean)|OR}} MIIM_TYPE
MenuItem.fType = MFT_STRING
MenuItem.fState = MFS_ENABLED
MenuItem.wID = count
TypeData = "&Fire Laser!" + {{Cl|CHR$}}(0)
MenuItem.dwTypeData = {{Cl|_OFFSET (function)|_OFFSET}}(TypeData)
MenuItem.cch = {{Cl|LEN}}(MenuItem.dwTypeData)
MyButton = MenuItem.wID
{{Cl|IF...THEN|IF}} InsertMenuItemA(hMenu, count, 1, {{Cl|_OFFSET (function)|_OFFSET}}(MenuItem)) {{Cl|THEN}} {{Cl|PRINT}} "Successfully added menu item!" {{Cl|ELSE}} {{Cl|PRINT}} "Failed to add menu item!": {{Cl|END}}

{{Cl|IF...THEN|IF}} SetMenu(hWnd, hMenu) {{Cl|THEN}} {{Cl|PRINT}} "Successfully set menu!": {{Cl|PRINT}} "Menu handle is:"; hMenu {{Cl|ELSE}} {{Cl|PRINT}} "Failed to set menu!": {{Cl|END}}

{{Cl|DO...LOOP|DO}}: {{Cl|_LIMIT}} 70
    prev_state = new_state
    ok = GetMenuItemInfoA(hMenu, MyButton, 1, {{Cl|_OFFSET (function)|_OFFSET}}(MenuItem))
    new_state = MenuItem.fState {{Cl|AND}} 128
    {{Cl|IF...THEN|IF}} prev_state = 0 {{Cl|AND (boolean)|AND}} new_state <> 0 {{Cl|THEN}} {{Cl|PRINT}} "Ouch! ";
{{Cl|LOOP}} {{Cl|WHILE}} {{Cl|INKEY$}} = ""
{{CodeEnd}}
{{Small|Code by Galleon}}
:Links/References:
:           [http://msdn.microsoft.com/en-us/library/windows/desktop/ms647980%28v=vs.85%29.aspx http://msdn.microsoft.com/en-us/library/windows/desktop/ms647980%28v=vs.85%29.aspx]


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows Notification ==

The following code creates a pop-up notification balloon in the Windows task bar or from the Windows 10 side bar.
{{CodeStart}}

'public domain, 2012 feb, michael calkins

{{Cl|CONST}} NIM_ADD = 0
{{Cl|CONST}} NIM_MODIFY = 1
{{Cl|CONST}} NIM_DELETE = 2

{{Cl|CONST}} NIF_ICON = 2
{{Cl|CONST}} NIF_TIP = 4
{{Cl|CONST}} NIF_INFO = {{Cl|&H}}10

{{Cl|CONST}} NIIF_NONE = 0
{{Cl|CONST}} NIIF_INFO = 1
{{Cl|CONST}} NIIF_WARNING = 2
{{Cl|CONST}} NIIF_ERROR = 3
{{Cl|CONST}} NIIF_USER = 4

{{Cl|CONST}} IDI_APPLICATION = 32512
{{Cl|CONST}} IDI_HAND = 32513
{{Cl|CONST}} IDI_QUESTION = 32514
{{Cl|CONST}} IDI_EXCLAMATION = 32515
{{Cl|CONST}} IDI_ASTERISK = 32516

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
 {{Cl|FUNCTION}} GetLastError~& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
 {{Cl|FUNCTION}} FindWindowA%& ({{Cl|BYVAL}} lpClassName%&, {{Cl|BYVAL}} lpWindowName%&)
 {{Cl|FUNCTION}} LoadIconA%& ({{Cl|BYVAL}} hInstance%&, {{Cl|BYVAL}} lpIconName%&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "shell32"
 {{Cl|FUNCTION}} Shell_NotifyIconA& ({{Cl|BYVAL}} dwMessage~&, {{Cl|BYVAL}} lpdata%&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|TYPE}} {{Cl|NOT}}IFYICONDATA
 cbSize {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 hWnd {{Cl|AS}} {{Cl|_OFFSET}}
 uID {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 uFlags {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 uCallbackMessage {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 hIcon {{Cl|AS}} {{Cl|_OFFSET}}
 szTip {{Cl|AS}} {{Cl|STRING}} * 128
 dwState {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 dwStateMask {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 szInfo {{Cl|AS}} {{Cl|STRING}} * 256
 uTimeout {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
 szInfoTitle {{Cl|AS}} {{Cl|STRING}} * 64
 dwInfoFlags {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|END}} {{Cl|TYPE}}

{{Cl|DIM}} hWnd {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|DIM}} hIcon {{Cl|AS}} {{Cl|_OFFSET}}
{{Cl|DIM}} t {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} notifydata {{Cl|AS}} NOTIFYICONDATA
notifydata.cbSize = {{Cl|LEN}}(notifydata)

t = "qb64 notification test"
{{Cl|_TITLE}} t
t = t + {{Cl|CHR$}}(0)
hWnd = {{Cl|_WINDOWHANDLE}} 'FindWindowA(0, {{Cl|_OFFSET (function)|_OFFSET}}(t)) 'find window ID
{{Cl|IF...THEN|IF}} hWnd = 0 {{Cl|THEN}}
 {{Cl|PRINT}} "FindWindowA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END}}
{{Cl|END IF}}

hIcon = LoadIconA(0, IDI_ASTERISK)
{{Cl|IF...THEN|IF}} hIcon = 0 {{Cl|THEN}}
 {{Cl|PRINT}} "LoadIconA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
{{Cl|END IF}}
'first notification
notifydata.hWnd = hWnd
notifydata.uID = 0
notifydata.uFlags = NIF_ICON {{Cl|OR (boolean)|OR}} NIF_TIP {{Cl|OR (boolean)|OR}} NIF_INFO
notifydata.hIcon = hIcon
notifydata.szTip = "Connect charger!" + {{Cl|CHR$}}(0) 'tool tip
notifydata.szInfo = "Recharge" + {{Cl|CHR$}}(0) 'information
notifydata.uTimeout = 10000 'milliseconds
notifydata.szInfoTitle = "Low Battery" + {{Cl|CHR$}}(0) 'balloon title FALSE LOW BATTERY warning
notifydata.dwInfoFlags = NIIF_INFO

{{Cl|IF...THEN|IF}} 0 = Shell_NotifyIconA(NIM_ADD, {{Cl|_OFFSET (function)|_OFFSET}}(notifydata)) {{Cl|THEN}}
 {{Cl|PRINT}} "Shell_NotifyIconA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END}}
{{Cl|END IF}}

{{Cl|PRINT}} "Press any key to modify it."
{{Cl|SLEEP}}: {{Cl|DO...LOOP|DO}} {{Cl|WHILE}} {{Cl|LEN}}({{Cl|INKEY$}}): {{Cl|LOOP}}

hIcon = LoadIconA(0, IDI_HAND)
{{Cl|IF...THEN|IF}} hIcon = 0 {{Cl|THEN}}
 {{Cl|PRINT}} "LoadIconA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
{{Cl|END IF}}
'second notification
notifydata.uFlags = NIF_ICON {{Cl|OR (boolean)|OR}} NIF_TIP {{Cl|OR (boolean)|OR}} NIF_INFO
notifydata.hIcon = hIcon
notifydata.szTip = "hahaha" + {{Cl|CHR$}}(0)
notifydata.szInfo = ":-)" + {{Cl|CHR$}}(0)
notifydata.uTimeout = 10000 'milliseconds
notifydata.szInfoTitle = "Howdy." + {{Cl|CHR$}}(0)
notifydata.dwInfoFlags = NIIF_WARNING

{{Cl|IF...THEN|IF}} 0 = Shell_NotifyIconA(NIM_MODIFY, {{Cl|_OFFSET (function)|_OFFSET}}(notifydata)) {{Cl|THEN}}
 {{Cl|PRINT}} "Shell_NotifyIconA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END}}
{{Cl|END IF}}


{{Cl|PRINT}} "Press any key to delete the notification icon."
{{Cl|SLEEP}}: {{Cl|DO...LOOP|DO}} {{Cl|WHILE}} {{Cl|LEN}}({{Cl|INKEY$}}): {{Cl|LOOP}}

{{Cl|IF...THEN|IF}} 0 = Shell_NotifyIconA(NIM_DELETE, {{Cl|_OFFSET (function)|_OFFSET}}(notifydata)) {{Cl|THEN}}
 {{Cl|PRINT}} "Shell_NotifyIconA failed. Error: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(GetLastError))
 {{Cl|END}}
{{Cl|END IF}}

{{Cl|END}}
{{CodeEnd}}
{{Small|Adapted from code by Michael Calkins}}
<center>'''NOTE: The program emulates a FALSE Low Battery warning!</center>


: ''MSDN References:''
<center>[http://msdn.microsoft.com/en-us/library/windows/desktop/ms633499%28v=vs.85%29.aspx http://msdn.microsoft.com/en-us/library/windows/desktop/ms633499%28v=vs.85%29.aspx]

[http://msdn.microsoft.com/en-us/library/windows/desktop/ms648072%28v=vs.85%29.aspx http://msdn.microsoft.com/en-us/library/windows/desktop/ms648072%28v=vs.85%29.aspx]

[http://msdn.microsoft.com/en-us/library/windows/desktop/bb762159%28v=vs.85%29.aspx http://msdn.microsoft.com/en-us/library/windows/desktop/bb762159%28v=vs.85%29.aspx]

[http://msdn.microsoft.com/en-us/library/windows/desktop/bb773352%28v=vs.85%29.aspx http://msdn.microsoft.com/en-us/library/windows/desktop/bb773352%28v=vs.85%29.aspx] </center>


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows Ports ==

: The following library uses QueryDosDeviceA to find the COM or LPT ports on a Windows computer only.
{{CodeStart}}
'this example uses QueryDosDeviceA to enumerate COM ports.
'public domain, sept 2011, michael calkins

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "kernel32"
 {{Cl|FUNCTION}} QueryDosDeviceA~& ({{Cl|BYVAL}} lpDeviceName {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} lpTargetPath {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|_OFFSET}}, {{Cl|BYVAL}} ucchMax {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}})
 {{Cl|FUNCTION}} GetLastError~& ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} sizeofbuffer {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} buffer {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} i {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} x {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
{{Cl|DIM}} n {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}}
sizeofbuffer = 1024
buffer = {{Cl|SPACE$}}(sizeofbuffer)

DO
 x = 0
 {{Cl|IF...THEN|IF}} QueryDosDeviceA~&(0, {{Cl|_OFFSET (function)|_OFFSET}}(buffer), sizeofbuffer) = 0 {{Cl|THEN}}
  x = GetLastError~&
  {{Cl|IF...THEN|IF}} x = {{Cl|&H}}7A {{Cl|THEN}}
   sizeofbuffer = sizeofbuffer + 1024
   buffer = {{Cl|SPACE$}}(sizeofbuffer)
  {{Cl|ELSE}}
   {{Cl|PRINT}} "Error: 0x"; {{Cl|HEX$}}(x)
   {{Cl|END}}
  {{Cl|END IF}}
 {{Cl|END IF}}
{{Cl|LOOP}} {{Cl|WHILE}} x = {{Cl|&H}}7A

i = 1
n = 0
{{Cl|DO...LOOP|DO}} {{Cl|WHILE}} {{Cl|ASC (function)|ASC}}({{Cl|MID$ (function)|MID$}}(buffer, i, 1))
 x = {{Cl|INSTR}}(i, buffer, {{Cl|CHR$}}(0))
 {{Cl|PRINT}} {{Cl|MID$ (function)|MID$}}(buffer, i, x - i)
 {{Cl|IF...THEN|IF}} {{Cl|MID$ (function)|MID$}}(buffer, i, 3) = "COM" {{Cl|THEN}} 'change to "LPT" for parallel ports
  {{Cl|REDIM}} {{Cl|_PRESERVE}} comports(0 {{Cl|TO}} (n * 2) + 1) {{Cl|AS}} {{Cl|STRING}}
  comports(n * 2) = {{Cl|MID$ (function)|MID$}}(buffer, i, (x - i) + 1)
  n = n + 1
 {{Cl|END IF}}
 i = x + 1
{{Cl|LOOP}}

{{Cl|PRINT}}
{{Cl|PRINT}} n; "COM ports:"
{{Cl|IF...THEN|IF}} n {{Cl|THEN}}
 {{Cl|FOR...NEXT|FOR}} i = 0 {{Cl|TO}} n - 1
  DO
   x = 0
   {{Cl|IF...THEN|IF}} QueryDosDeviceA~&({{Cl|_OFFSET (function)|_OFFSET}}(comports(i * 2)), {{Cl|_OFFSET (function)|_OFFSET}}(buffer), sizeofbuffer) = 0 {{Cl|THEN}}
    x = GetLastError~&
    {{Cl|IF...THEN|IF}} x = {{Cl|&H}}7A {{Cl|THEN}}
     sizeofbuffer = sizeofbuffer + 1024
     buffer = {{Cl|SPACE$}}(sizeofbuffer)
    {{Cl|ELSE}}
     {{Cl|PRINT}} "Error: 0x"; {{Cl|HEX$}}(x)
     {{Cl|END}}
    {{Cl|END IF}}
   {{Cl|END IF}}
  {{Cl|LOOP}} {{Cl|WHILE}} x = {{Cl|&H}}7A
  comports((i * 2) + 1) = {{Cl|LEFT$}}(buffer, {{Cl|INSTR}}(buffer, {{Cl|CHR$}}(0)) - 1)
  comports(i * 2) = {{Cl|LEFT$}}(comports(i * 2), {{Cl|LEN}}(comports(i * 2)) - 1)
  {{Cl|PRINT}} {{Cl|CHR$}}({{Cl|&H}}22); comports(i * 2); {{Cl|CHR$}}({{Cl|&H}}22); " is mapped to: "; {{Cl|CHR$}}({{Cl|&H}}22); comports((i * 2) + 1); {{Cl|CHR$}}({{Cl|&H}}22)
 {{Cl|NEXT}}
{{Cl|END IF}}

buffer = ""

{{Cl|END}}
{{CodeEnd}}
{{Small|Code courtesy of Michael Calkins}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows Sounds ==

: MessageBeep plays Windows alert sound files located in the ''C:\windows\media'' folder. Some may not be set!
{{CodeStart}}
{{Cl|CONST}} MB_OK = 0 'beep
{{Cl|CONST}} MB_ICONERROR = {{Cl|&H}}10
{{Cl|CONST}} MB_ICONQUESTION = {{Cl|&H}}20
{{Cl|CONST}} MB_ICONWARNING = {{Cl|&H}}30
{{Cl|CONST}} MB_ICONASTERISK = {{Cl|&H}}40

{{Cl|DECLARE LIBRARY}}
  {{Cl|SUB}} MessageBeep ({{Cl|BYVAL}} alert {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|PRINT}} "OK"
MessageBeep MB_OK

{{Cl|SLEEP}} 2
{{Cl|PRINT}} "Error"
MessageBeep MB_ICONERROR

{{Cl|SLEEP}} 2
{{Cl|PRINT}} "?"
MessageBeep MB_ICONQUESTION

{{Cl|SLEEP}} 2
{{Cl|PRINT}} "Warning"
MessageBeep MB_ICONWARNING

{{Cl|SLEEP}} 2
{{Cl|PRINT}} "Asterisk"
MessageBeep MB_ICONASTERISK
{{CodeEnd}}
{{Small|Code by Ted Weissgerber}}
: ''Note:'' The sounds can be set in ''Control Panel: Sounds and Audio Devices/Sounds'' settings tab if not already assigned.


: PlaySound plays Windows System sounds on most PC's:
{{CodeStart}}'SDL-SPECIFIC CHANGES! GL only needs DECLARE LIBRARY without DLL name

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "Winmm"
    {{Cl|FUNCTION}} PlaySound (pszSound {{Cl|AS}} {{Cl|STRING}}, {{Cl|BYVAL}} hmod {{Cl|AS}} {{Cl|INTEGER}}, {{Cl|BYVAL}} fdwSound {{Cl|AS}} {{Cl|INTEGER}})
{{Cl|DECLARE LIBRARY|END DECLARE}}
{{Cl|CONST}} SND_{{Cl|ALIAS}} = 65536
{{Cl|CONST}} SND_ASYNC = 1

x = PlaySound("SystemExclamation" + {{Cl|CHR$}}(0), 0, SND_{{Cl|ALIAS}} + SND_ASYNC)
{{CodeEnd}}

: Use "SystemDefault", "SystemExclamation", "SystemExit", "SystemHand", "SystemQuestion", "SystemStart" or "SystemWelcome"



<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Window Transparency ==


: Program changes transparency of the window. Plus key increases visibility while minus key can make it completely invisible.
{{CodeStart}}
{{Cl|DEFINT}} A-Z

' Declare windows API functions
{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "user32"
   {{Cl|FUNCTION}} SetLayeredWindowAttributes& ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} crKey {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} bAlpha {{Cl|AS}} {{Cl|_UNSIGNED}} {{Cl|_BYTE}}, {{Cl|BYVAL}} dwFlags {{Cl|AS}} {{Cl|LONG}})
   {{Cl|FUNCTION}} GetWindowLong& {{Cl|ALIAS}} "GetWindowLongA" ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nIndex {{Cl|AS}} {{Cl|LONG}})
   {{Cl|FUNCTION}} SetWindowLong& {{Cl|ALIAS}} "SetWindowLongA" ({{Cl|BYVAL}} hwnd {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} nIndex {{Cl|AS}} {{Cl|LONG}}, {{Cl|BYVAL}} dwNewLong {{Cl|AS}} {{Cl|LONG}})
{{Cl|DECLARE LIBRARY|END DECLARE}}

' Needed for acquiring the hWnd of the window
{{Cl|DECLARE LIBRARY}}
   {{Cl|FUNCTION}} FindWindow& ({{Cl|BYVAL}} ClassName {{Cl|AS}} {{Cl|_OFFSET}}, WindowName$) ' To get hWnd handle
{{Cl|DECLARE LIBRARY|END DECLARE}}


{{Cl|DIM}} MyHwnd {{Cl|AS}} {{Cl|LONG}}

' Get hWnd value
{{Cl|_TITLE}} "Translucent window test"
MyHwnd = {{Cl|_WINDOWHANDLE}} 'FindWindow(0, "Translucent window test" + {{Cl|CHR$}}(0))


' Set screen and draw a simple fractal which looks cooler than a black translucent window
{{Cl|SCREEN}} {{Cl|_NEWIMAGE}}(640, 480, 32)

{{Cl|FOR...NEXT|FOR}} Py = 0 {{Cl|TO}} 479
   {{Cl|FOR...NEXT|FOR}} Px = 0 {{Cl|TO}} 639
      {{Cl|PSET}} (Px, Py), {{Cl|_RGB32}}((Px {{Cl|OR (boolean)|OR}} Py) {{Cl|MOD}} 256, (Px + Py) {{Cl|MOD}} 256, Py {{Cl|MOD}} 256)
   {{Cl|NEXT}} Px
{{Cl|NEXT}} Py


' Main loop
{{Cl|PRINT}} "Press +/- to change opacity"

Level = 127
SetWindowOpacity MyHwnd, Level
DO
   Press$ = {{Cl|INKEY$}}
   {{Cl|LOCATE}} 2, 1: {{Cl|PRINT}} "Opacity:"; Level

   ' Change window opacity whenever +/- are pressed
   {{Cl|IF...THEN|IF}} Press$ = "+" {{Cl|AND (boolean)|AND}} Level < 255 {{Cl|THEN}} Level = Level + 1: SetWindowOpacity MyHwnd, Level
   {{Cl|IF...THEN|IF}} Press$ = "-" {{Cl|AND (boolean)|AND}} Level > 0 {{Cl|THEN}} Level = Level - 1: SetWindowOpacity MyHwnd, Level

   {{Cl|_LIMIT}} 60

{{Cl|LOOP}} {{Cl|UNTIL}} Press$ = {{Cl|CHR$}}(27)
{{Cl|SYSTEM}}


'====================================================================\
{{Cl|SUB}} SetWindowOpacity (hWnd {{Cl|AS}} {{Cl|LONG}}, Level)
{{Cl|DIM}} Msg {{Cl|AS}} {{Cl|LONG}}
{{Cl|CONST}} G = -20
{{Cl|CONST}} LWA_ALPHA = {{Cl|&H}}2
{{Cl|CONST}} WS_EX_LAYERED = {{Cl|&H}}80000

Msg = GetWindowLong(hWnd, G)
Msg = Msg {{Cl|OR (boolean)|OR}} WS_EX_LAYERED
Crap = SetWindowLong(hWnd, G, Msg)
Crap = SetLayeredWindowAttributes(hWnd, 0, Level, LWA_ALPHA)

{{Cl|END SUB}}
{{CodeEnd}}
{{Small|Code by Jobert}}


<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows User ==

: Finds the current user's ''My Documents'' folder as a [[STRING]] value. Other environmental constants are listed below code.
{{CodeStart}}
'public domain

{{Cl|CONST}} MAX_PATH = 260             'maximum length of path string
{{Cl|CONST}} CSIDL_PERSONAL = {{Cl|&H}}5       'User's My Documents path. See environmental constants below
{{Cl|CONST}} SHGFP_TYPE_CURRENT = 0

{{Cl|CONST}} S_OK = 0                   'environmental value found
{{Cl|CONST}} S_FALSE = {{Cl|&H}}1              'folder does not exist
{{Cl|CONST}} E_FAILED = {{Cl|&H}}80004005&     'folder does not exist
{{Cl|CONST}} E_INVALIDARG = {{Cl|&H}}80070057& 'invalid argument parameter

{{Cl|DECLARE LIBRARY|DECLARE DYNAMIC LIBRARY}} "shell32"
 {{Cl|FUNCTION}} SHGetFolderPathA& ({{Cl|BYVAL}} hwndOwner%&, {{Cl|BYVAL}} nFolder&, {{Cl|BYVAL}} hToken%&, {{Cl|BYVAL}} dwFlags~&, {{Cl|BYVAL}} pszPath%&)
{{Cl|DECLARE LIBRARY|END DECLARE}}

{{Cl|DIM}} path {{Cl|AS}} {{Cl|STRING}}
{{Cl|DIM}} hr {{Cl|AS}} {{Cl|LONG}}
{{Cl|DIM}} n {{Cl|AS}} {{Cl|LONG}}

path = {{Cl|STRING$}}(MAX_PATH, 0) 'enlarge the string to MAX_PATH

hr = SHGetFolderPathA(0, CSIDL_PERSONAL, 0, SHGFP_TYPE_CURRENT, {{Cl|_OFFSET (function)|_OFFSET}}(path))
{{Cl|IF...THEN|IF}} hr {{Cl|THEN}}
 {{Cl|PRINT}} "hresult: 0x" + {{Cl|LCASE$}}({{Cl|HEX$}}(hr)) 'function returns non-zero error code
 {{Cl|END}}
{{Cl|END IF}}

n = {{Cl|INSTR}}(path, {{Cl|CHR$}}(0)) 'find terminating null

path = {{Cl|LEFT$}}(path, n - 1) 'shrink the string (probably creates a temp string)
{{Cl|PRINT}} {{Cl|CHR$}}({{Cl|&H}}22); path; {{Cl|CHR$}}({{Cl|&H}}22)
{{Cl|END}}
{{CodeEnd}}
{{Small|Code courtesy of Michael Calkins}}
: ''Note:'' When the SHGetFolderPathA& function returns a non-zero value, the 0x hexadecimal error number is printed instead.

<center>'''[http://msdn.microsoft.com/en-us/library/bb776911(v=vs.85) Vista and newer versions of Windows can also use SHGetKnownFolderPath and similar Constant values]'''</center>

{{FixedStart}}                              '''Windows CSIDL Environmental [[LONG]] Constants'''

 CONST CSIDL_DESKTOP = &H0                  '<user name>\desktop
 CONST CSIDL_INTERNET = &H1                 'Internet Explorer(icon on desktop)
 CONST CSIDL_PROGRAMS = &H2                 '<user name>\Start Menu\Programs
 CONST CSIDL_CONTROLS = &H3                 'My Computer\Control Panel icon group
 CONST CSIDL_PRINTERS = &H4                 'My Computer\Printers (installed)
 CONST CSIDL_PERSONAL = &H5                 '<user name>\My Documents
 CONST CSIDL_FAVORITES = &H6                '<user name>\Favorites
 CONST CSIDL_STARTUP = &H7                  '<user name>\Start Menu\Programs\Startup
 CONST CSIDL_RECENT = &H8                   '<user name>\Recent
 CONST CSIDL_SENDTO = &H9                   '<user name>\SendTo
 CONST CSIDL_BITBUCKET = &HA                '<user desktop>\Recycle Bin
 CONST CSIDL_STARTMENU = &HB                '<user name>\Start Menu
 CONST CSIDL_MYDOCUMENTS = &HC              'logical "My Documents" desktop icon
 CONST CSIDL_MYMUSIC = &HD                  '<user name>\My Documents\My Music folder
 CONST CSIDL_MYVIDEO = &HE                  '<user name>\My Documents\My Videos folder
 CONST CSIDL_DESKTOPDIRECTORY = &H10        '<user name>\Desktop
 CONST CSIDL_DRIVES = &H11                  'My Computer
 CONST CSIDL_NETWORK = &H12                 'Network Neighborhood (My Network Places)
 CONST CSIDL_NETHOOD = &H13                 '<user name>\nethood
 CONST CSIDL_FONTS = &H14                   'windows\fonts
 CONST CSIDL_TEMPLATES = &H15               'templates
 CONST CSIDL_COMMON_STARTMENU = &H16        'All Users\Start Menu
 CONST CSIDL_COMMON_PROGRAMS = &H17         'All Users\Start Menu\Programs
 CONST CSIDL_COMMON_STARTUP = &H18          'All Users\Startup
 CONST CSIDL_COMMON_DESKTOPDIRECTORY = &H19 'All Users\Startup
 CONST CSIDL_APPDATA = &H1A                 '<user name>\Application Data
 CONST CSIDL_PRINTHOOD = &H1B               '<user name>\PrintHood
 CONST CSIDL_LOCAL_APPDATA = &H1C           '<user name>\Local Settings\Application Data
 CONST CSIDL_ALTSTARTUP = &H1D              'non-localized startup(Vista only)
 CONST CSIDL_COMMON_ALTSTARTUP = &H1E       'common startup
 CONST CSIDL_COMMON_FAVORITES = &H1F        'common startup
 CONST CSIDL_INTERNET_CACHE = &H20          'common startup
 CONST CSIDL_COOKIES = &H21                 'common startup
 CONST CSIDL_HISTORY = &H22                 'common startup
 CONST CSIDL_COMMON_APPDATA = &H23          'All Users\Application Data
 CONST CSIDL_WINDOWS = &H24                 'GetWindowsDirectory()
 CONST CSIDL_SYSTEM = &H25                  'GetSystemDirectory()
 CONST CSIDL_PROGRAM_FILES = &H26           'C:\Program Files
 CONST CSIDL_MYPICTURES = &H27              '<user name>\My Documents\My Pictures
 CONST CSIDL_PROFILE = &H28                 'USERPROFILE
 CONST CSIDL_SYSTEMX86 = &H29               'x86 C:\Windows\System32 or [[SysWOW64]](64 bit PC)
 CONST CSIDL_PROGRAM_FILESX86 = &H2A        'x86 C:\Program Files on RISC
 CONST CSIDL_PROGRAM_FILES_COMMON = &H2B    'C:\Program Files\Common
 CONST CSIDL_PROGRAM_FILES_COMMONX86 = &H2C 'x86 Program Files\Common on RISC
 CONST CSIDL_COMMON_TEMPLATES = &H2D        'All Users\Templates
 CONST CSIDL_COMMON_DOCUMENTS = &H2E        'All Users\Documents
 CONST CSIDL_COMMON_ADMINTOOLS = &H2F       'All Users\Start Menu\Programs\Administrative Tools
 CONST CSIDL_ADMINTOOLS = &H30              '<user name>\Start Menu\Programs\Administrative Tools
 CONST CSIDL_CONNECTIONS = &H31             'Network and Dial-up Connections
 CONST CSIDL_COMMON_MUSIC = &H35            'All Users\My Music
 CONST CSIDL_COMMON_PICTURES = &H36         'All Users\My Pictures
 CONST CSIDL_COMMON_VIDEO = &H37            'All Users\My Video
 CONST CSIDL_RESOURCES = &H38               'Resource Directory
 CONST CSIDL_RESOURCES_LOCALIZED = &H39     'Localized Resource Directory
 CONST CSIDL_COMMON_OEM_LINKS = &H3A        'Links to All Users OEM specific apps
 CONST CSIDL_CDBURN_AREA = &H3B             'USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning

                 'See: [http://msdn.microsoft.com/en-us/library/bb762181%28v=vs.85%29 http://msdn.microsoft.com/en-us/library/bb762181%28v=vs.85%29]
{{FixedEnd}}
<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>


== Windows Version ==

<center>'''Note that QB64 will not run on Windows 95 to ME computers currently!'''</center>

{{CodeStart}}
{{Cl|DECLARE LIBRARY}}
  {{Cl|FUNCTION}} GetVersion ()
{{Cl|DECLARE LIBRARY|END DECLARE}}

'Just grab the "build" number...
b$ = {{Cl|LTRIM$}}({{Cl|RTRIM$}}({{Cl|STR$}}((GetVersion {{Cl|AND (boolean)|AND}} {{Cl|&H}}FFFF0000) \ {{Cl|&H}}10000)))


{{Cl|PRINT}} "The Windows version is: ";

{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "095") {{Cl|THEN}} {{Cl|PRINT}} "Windows 95"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "1111") {{Cl|THEN}} {{Cl|PRINT}} "Windows 95"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "1381") {{Cl|THEN}} {{Cl|PRINT}} "Windows NT"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "1998") {{Cl|THEN}} {{Cl|PRINT}} "Windows 98"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "2222") {{Cl|THEN}} {{Cl|PRINT}} "Windows 98 SE"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "3000") {{Cl|THEN}} {{Cl|PRINT}} "Windows ME"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "2195") {{Cl|THEN}} {{Cl|PRINT}} "Windows 2000"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "2600") {{Cl|THEN}} {{Cl|PRINT}} "Windows XP"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "3790") {{Cl|THEN}} {{Cl|PRINT}} "Windows Server 2003"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "6000") {{Cl|THEN}} {{Cl|PRINT}} "Windows Vista/Server"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "6001") {{Cl|THEN}} {{Cl|PRINT}} "Windows Vista/Server"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "6002") {{Cl|THEN}} {{Cl|PRINT}} "Windows Vista/Server"
{{Cl|IF...THEN|IF}} {{Cl|INSTR}}(1, b$, "7600") {{Cl|THEN}} {{Cl|PRINT}} "Windows 7"
{{CodeEnd}}
{{Small|Code courtesy of Dav}}
'''NOTE''': Microsoft depreciated GetVersion() for Windows 8 and higher - [https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion]

<p style="text-align: center">([[#toc|Return to Table of Contents]])</p>

<center> '''Note: C++ Header files should be placed in the QB64 folder and are not required after a program is compiled.'''</center>


<center>'''{{Text|Your code contribution using the Windows Libraries could end up here!|magenta}}'''</center>


{{PageSeeAlso}}
* [[_WINDOWHANDLE]]
* [[Windows Environment]]
* [[DECLARE LIBRARY]], [[BYVAL]], [[ALIAS]]
* [[_OFFSET]], [[_OFFSET (function)]]
* [[DLL Libraries]], [[C Libraries]]
* [[Libraries#C++_Variable_Types|C++ Variable Types]]
* [[Windows Printer Settings]]


{{PageNavigation}}
